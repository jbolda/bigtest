diff --git a/node_modules/@effection/node/dist/child_process.d.ts b/node_modules/@effection/node/dist/child_process.d.ts
index 9c8f7ec..5eb6c29 100644
--- a/node_modules/@effection/node/dist/child_process.d.ts
+++ b/node_modules/@effection/node/dist/child_process.d.ts
@@ -1,6 +1,7 @@
 /// <reference types="node" />
-import { Operation } from 'effection';
-import { SpawnOptions, ForkOptions } from 'child_process';
-export { ChildProcess } from 'child_process';
+import { Operation } from "effection";
+import { SpawnOptions, ForkOptions, ChildProcess } from "child_process";
+export { ChildProcess } from "child_process";
 export declare function spawn(command: string, args?: ReadonlyArray<string>, options?: SpawnOptions): Operation;
+export declare function spawnProcess(command: string, args?: ReadonlyArray<string>, options?: SpawnOptions): ChildProcess;
 export declare function fork(module: string, args?: ReadonlyArray<string>, options?: ForkOptions): Operation;
diff --git a/node_modules/@effection/node/dist/index.d.ts b/node_modules/@effection/node/dist/index.d.ts
index 5c22657..be5de81 100644
--- a/node_modules/@effection/node/dist/index.d.ts
+++ b/node_modules/@effection/node/dist/index.d.ts
@@ -1,2 +1,3 @@
 export { main, MainError } from './main';
-export * as ChildProcess from './child_process';
+import * as ChildProcess from './child_process';
+export { ChildProcess };
diff --git a/node_modules/@effection/node/dist/node.cjs.development.js b/node_modules/@effection/node/dist/node.cjs.development.js
index 73488ab..7fd8c02 100644
--- a/node_modules/@effection/node/dist/node.cjs.development.js
+++ b/node_modules/@effection/node/dist/node.cjs.development.js
@@ -1,7 +1,12 @@
 'use strict';
 
+Object.defineProperty(exports, '__esModule', { value: true });
+
 var effection = require('effection');
 var events = require('@effection/events');
+var npmRunPath = require('npm-run-path');
+var TreeKill = require('tree-kill');
+var childProcessCross = require('cross-spawn');
 var childProcess = require('child_process');
 
 class MainError extends Error {
@@ -53,8 +58,10 @@ function main(operation) {
   });
 }
 
+const treeKill = TreeKill;
+
 function* supervise(child, command, args = []) {
-  // Killing all child processes started by this command is surprisingly
+  let forceKillSignal = "SIGKILL"; // Killing all child processes started by this command is surprisingly
   // tricky. If a process spawns another processes and we kill the parent,
   // then the child process is NOT automatically killed. Instead we're using
   // the `detached` option to force the child into its own process group,
@@ -64,37 +71,114 @@ function* supervise(child, command, args = []) {
   // process.
   //
   // More information here: https://unix.stackexchange.com/questions/14815/process-descendants
+  // Windows is even more tricky as it doesn't have the process groups and
+  // doesn't have signals. We resort to `treeKill` which does not gracefully
+  // shut down the processes, but it is the best we have?
+
   try {
     yield events.throwOnErrorEvent(child);
-    let [code] = yield events.once(child, "exit");
+    let [code, signal] = yield events.once(child, "exit");
+    if (typeof signal === "string") forceKillSignal = signal;
 
     if (code !== 0) {
-      throw new Error(`'${(command + args.join(' ')).trim()}' exited with non-zero exit code`);
+      throw new Error(`'${(command + args.join(" ")).trim()}' exited with non-zero exit code`);
     }
   } finally {
     try {
-      process.kill(-child.pid, "SIGTERM");
+      if (process.platform === 'win32') {
+        var _child$stdout, _child$stderr;
+
+        // @ts-ignore
+        child === null || child === void 0 ? void 0 : (_child$stdout = child.stdout) === null || _child$stdout === void 0 ? void 0 : _child$stdout.end(); // @ts-ignore
+
+        child === null || child === void 0 ? void 0 : (_child$stderr = child.stderr) === null || _child$stderr === void 0 ? void 0 : _child$stderr.end();
+        treeKill(child.pid, forceKillSignal, err => {});
+      } else {
+        process.kill(-child.pid, "SIGTERM");
+      }
     } catch (e) {// do nothing, process is probably already dead
     }
   }
 }
 
+const withDefaults = options => {
+  return {
+    // When windows shell is true, it runs with cmd.exe by default, but
+    // node has trouble with PATHEXT and exe. It can't run exe directly for example.
+    // `cross-spawn` handles running it with the shell in windows if needed.
+    // Neither mac nor linux need shell and we run it detached.
+    // shell: ~false,
+    // With stdio as pipe, windows gets stuck where neither the child nor the
+    // parent wants to close the stream, so we call it ourselves in the exit event.
+    stdio: "pipe",
+    // We lose exit information and events if this is detached in windows
+    // and it opens a window in windows+powershell.
+    detached: process.platform === "win32" ? false : true,
+    cwd: (options === null || options === void 0 ? void 0 : options.cwd) || process.cwd(),
+    env: npmRunPath.env({
+      env: Object.assign({}, process.env, options === null || options === void 0 ? void 0 : options.env),
+      cwd: (options === null || options === void 0 ? void 0 : options.cwd) || process.cwd(),
+      execPath: process.execPath
+    })
+  };
+}; // Windows can't run exe through the child_process so it creates
+// these .cmd files that can instead be run. Adjust for it here.
+
+
+const c = command => {
+  if (process.platform !== "win32") return command;
+
+  if (command === "npm" || command === "yarn") {
+    return `${command}.cmd`;
+  } else {
+    return command;
+  }
+};
+
 function* spawn(command, args, options) {
-  let child = childProcess.spawn(command, args || [], Object.assign({}, options, {
-    detached: true
-  }));
+  var _child$stdin;
+
+  let child = childProcessCross.spawn(c(command), args || [], withDefaults(options));
+  child === null || child === void 0 ? void 0 : (_child$stdin = child.stdin) === null || _child$stdin === void 0 ? void 0 : _child$stdin.end();
   return yield effection.resource(child, supervise(child, command, args));
 }
+function spawnProcess(command, args, options) {
+  var _spawned$stdin;
+
+  const spawned = childProcessCross.spawn(c(command), args || [], withDefaults(options));
+  spawned === null || spawned === void 0 ? void 0 : (_spawned$stdin = spawned.stdin) === null || _spawned$stdin === void 0 ? void 0 : _spawned$stdin.end();
+  spawned.once("exit", (code, signal) => {
+    const safeSignal = signal === null ? 'SIGTERM' : signal;
+
+    try {
+      if (process.platform === 'win32') {
+        var _spawned$stdout, _spawned$stderr;
+
+        // @ts-ignore
+        spawned === null || spawned === void 0 ? void 0 : (_spawned$stdout = spawned.stdout) === null || _spawned$stdout === void 0 ? void 0 : _spawned$stdout.end(); // @ts-ignore
+
+        spawned === null || spawned === void 0 ? void 0 : (_spawned$stderr = spawned.stderr) === null || _spawned$stderr === void 0 ? void 0 : _spawned$stderr.end();
+        treeKill(spawned.pid, safeSignal, err => {});
+      } else {
+        process.kill(-spawned.pid, safeSignal);
+      }
+    } catch (e) {// do nothing, process is probably already dead
+    }
+  });
+  return spawned;
+}
 function* fork(module, args, options) {
-  let child = childProcess.fork(module, args, Object.assign({}, options, {
-    detached: true
-  }));
+  var _child$stdin2;
+
+  let child = childProcess.fork(module, args, withDefaults(options));
+  child === null || child === void 0 ? void 0 : (_child$stdin2 = child.stdin) === null || _child$stdin2 === void 0 ? void 0 : _child$stdin2.end();
   return yield effection.resource(child, supervise(child, module, args));
 }
 
 var child_process = {
   __proto__: null,
   spawn: spawn,
+  spawnProcess: spawnProcess,
   fork: fork
 };
 
diff --git a/node_modules/@effection/node/dist/node.cjs.development.js.map b/node_modules/@effection/node/dist/node.cjs.development.js.map
index 84be1d8..7ea7718 100644
--- a/node_modules/@effection/node/dist/node.cjs.development.js.map
+++ b/node_modules/@effection/node/dist/node.cjs.development.js.map
@@ -1 +1 @@
-{"version":3,"file":"node.cjs.development.js","sources":["../src/main.ts","../src/child_process.ts"],"sourcesContent":["import { main as effectionMain, Context, Operation } from 'effection';\n\ninterface MainErrorOptions {\n  exitCode?: number;\n  verbose?: boolean;\n  message?: string;\n}\n\nexport class MainError extends Error {\n  name = \"EffectionMainError\"\n\n  constructor(public options: MainErrorOptions = {}) {\n    super(options.message || \"error\");\n  }\n}\n\nexport function main<T>(operation: Operation<T>): Context<T> {\n  return effectionMain(({ context: mainContext, spawn }) => {\n    spawn(function* main() {\n      let interrupt = () => { mainContext.halt(); };\n      let debug = () => console.debug(mainContext.toString());\n      try {\n        process.on('SIGINT', interrupt);\n        process.on('SIGTERM', interrupt);\n        process.on('SIGUSR1', debug);\n        return yield operation;\n      } catch(e) {\n        if(e.name === 'EffectionMainError') {\n          if(e.options.message) {\n            console.error(e.options.message);\n          }\n          if(e.options.verbose) {\n            console.error(e.stack);\n          }\n          process.exit(e.options.exitCode || -1);\n        } else {\n          console.error(e);\n          process.exit(-1);\n        }\n      } finally {\n        process.off('SIGINT', interrupt);\n        process.off('SIGTERM', interrupt);\n        process.off('SIGUSR1', debug);\n      }\n    });\n  });\n}\n","import { Operation, resource } from 'effection';\nimport { once, throwOnErrorEvent } from '@effection/events';\n\nimport * as childProcess from 'child_process';\nimport { SpawnOptions, ForkOptions, ChildProcess } from 'child_process';\n\nexport { ChildProcess } from 'child_process';\n\nfunction *supervise(child: ChildProcess, command: string, args: readonly string[] = []) {\n  // Killing all child processes started by this command is surprisingly\n  // tricky. If a process spawns another processes and we kill the parent,\n  // then the child process is NOT automatically killed. Instead we're using\n  // the `detached` option to force the child into its own process group,\n  // which all of its children in turn will inherit. By sending the signal to\n  // `-pid` rather than `pid`, we are sending it to the entire process group\n  // instead. This will send the signal to all processes started by the child\n  // process.\n  //\n  // More information here: https://unix.stackexchange.com/questions/14815/process-descendants\n  try {\n    yield throwOnErrorEvent(child);\n\n    let [code]: [number] = yield once(child, \"exit\");\n    if(code !== 0) {\n      throw new Error(`'${(command + args.join(' ')).trim()}' exited with non-zero exit code`);\n    }\n  } finally {\n    try {\n      process.kill(-child.pid, \"SIGTERM\")\n    } catch(e) {\n      // do nothing, process is probably already dead\n    }\n  }\n}\n\nexport function *spawn(command: string, args?: ReadonlyArray<string>, options?: SpawnOptions): Operation {\n  let child = childProcess.spawn(command, args || [], Object.assign({}, options, {\n    detached: true,\n  }));\n  return yield resource(child, supervise(child, command, args));\n}\n\nexport function *fork(module: string, args?: ReadonlyArray<string>, options?: ForkOptions): Operation {\n  let child = childProcess.fork(module, args, Object.assign({}, options, {\n    detached: true,\n  }));\n  return yield resource(child, supervise(child, module, args));\n}\n"],"names":["MainError","Error","constructor","options","message","main","operation","effectionMain","context","mainContext","spawn","interrupt","halt","debug","console","toString","process","on","e","name","error","verbose","stack","exit","exitCode","off","supervise","child","command","args","throwOnErrorEvent","code","once","join","trim","kill","pid","childProcess","Object","assign","detached","resource","fork","module"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"node.cjs.development.js","sources":["../src/main.ts","../src/child_process.ts"],"sourcesContent":["import { main as effectionMain, Context, Operation } from 'effection';\r\n\r\ninterface MainErrorOptions {\r\n  exitCode?: number;\r\n  verbose?: boolean;\r\n  message?: string;\r\n}\r\n\r\nexport class MainError extends Error {\r\n  name = \"EffectionMainError\"\r\n\r\n  constructor(public options: MainErrorOptions = {}) {\r\n    super(options.message || \"error\");\r\n  }\r\n}\r\n\r\nexport function main<T>(operation: Operation<T>): Context<T> {\r\n  return effectionMain(({ context: mainContext, spawn }) => {\r\n    spawn(function* main() {\r\n      let interrupt = () => { mainContext.halt(); };\r\n      let debug = () => console.debug(mainContext.toString());\r\n      try {\r\n        process.on('SIGINT', interrupt);\r\n        process.on('SIGTERM', interrupt);\r\n        process.on('SIGUSR1', debug);\r\n        return yield operation;\r\n      } catch(e) {\r\n        if(e.name === 'EffectionMainError') {\r\n          if(e.options.message) {\r\n            console.error(e.options.message);\r\n          }\r\n          if(e.options.verbose) {\r\n            console.error(e.stack);\r\n          }\r\n          process.exit(e.options.exitCode || -1);\r\n        } else {\r\n          console.error(e);\r\n          process.exit(-1);\r\n        }\r\n      } finally {\r\n        process.off('SIGINT', interrupt);\r\n        process.off('SIGTERM', interrupt);\r\n        process.off('SIGUSR1', debug);\r\n      }\r\n    });\r\n  });\r\n}\r\n","import { Operation, resource } from \"effection\";\r\nimport { once, throwOnErrorEvent } from \"@effection/events\";\r\n\r\nimport * as npmRunPath from \"npm-run-path\";\r\nimport * as TreeKill from \"tree-kill\";\r\nconst treeKill: any = TreeKill;\r\nimport * as childProcessCross from \"cross-spawn\";\r\nimport * as childProcess from \"child_process\";\r\nimport { SpawnOptions, ForkOptions, ChildProcess } from \"child_process\";\r\n\r\nexport { ChildProcess } from \"child_process\";\r\n\r\nfunction* supervise(\r\n  child: ChildProcess,\r\n  command: string,\r\n  args: readonly string[] = []\r\n) {\r\n  let forceKillSignal: string = \"SIGKILL\"\r\n  // Killing all child processes started by this command is surprisingly\r\n  // tricky. If a process spawns another processes and we kill the parent,\r\n  // then the child process is NOT automatically killed. Instead we're using\r\n  // the `detached` option to force the child into its own process group,\r\n  // which all of its children in turn will inherit. By sending the signal to\r\n  // `-pid` rather than `pid`, we are sending it to the entire process group\r\n  // instead. This will send the signal to all processes started by the child\r\n  // process.\r\n  //\r\n  // More information here: https://unix.stackexchange.com/questions/14815/process-descendants\r\n  // Windows is even more tricky as it doesn't have the process groups and\r\n  // doesn't have signals. We resort to `treeKill` which does not gracefully\r\n  // shut down the processes, but it is the best we have?\r\n  try {\r\n    yield throwOnErrorEvent(child);\r\n    let [code, signal]: [number, any] = yield once(child, \"exit\");\r\n    if (typeof signal === \"string\") forceKillSignal = signal\r\n    if (code !== 0) {\r\n      throw new Error(\r\n        `'${(command + args.join(\" \")).trim()}' exited with non-zero exit code`\r\n      );\r\n    }\r\n  } finally {\r\n    try {\r\n      if (process.platform === 'win32') {\r\n        // @ts-ignore\r\n        child?.stdout?.end();\r\n        // @ts-ignore\r\n        child?.stderr?.end();\r\n        treeKill(child.pid, forceKillSignal, (err: any) => {/*no-op*/});\r\n      } else {\r\n        process.kill(-child.pid, \"SIGTERM\")\r\n      }\r\n    } catch(e) {\r\n      // do nothing, process is probably already dead\r\n    }\r\n  }\r\n}\r\n\r\nconst withDefaults = (options: SpawnOptions | undefined): SpawnOptions => {\r\n  return {\r\n    // When windows shell is true, it runs with cmd.exe by default, but\r\n    // node has trouble with PATHEXT and exe. It can't run exe directly for example.\r\n    // `cross-spawn` handles running it with the shell in windows if needed.\r\n    // Neither mac nor linux need shell and we run it detached.\r\n    // shell: ~false,\r\n    // With stdio as pipe, windows gets stuck where neither the child nor the\r\n    // parent wants to close the stream, so we call it ourselves in the exit event.\r\n    stdio: \"pipe\",\r\n    // We lose exit information and events if this is detached in windows\r\n    // and it opens a window in windows+powershell.\r\n    detached: process.platform === \"win32\" ? false : true,\r\n    cwd: options?.cwd || process.cwd(),\r\n    env: npmRunPath.env({\r\n      env: Object.assign({}, process.env, options?.env),\r\n      cwd: options?.cwd || process.cwd(),\r\n      execPath: process.execPath,\r\n    }),\r\n  };\r\n};\r\n\r\n// Windows can't run exe through the child_process so it creates\r\n// these .cmd files that can instead be run. Adjust for it here.\r\nconst c = (command: string) => {\r\n  if (process.platform !== \"win32\") return command;\r\n  if (command === \"npm\" || command === \"yarn\") {\r\n    return `${command}.cmd`;\r\n  } else {\r\n    return command;\r\n  }\r\n};\r\n\r\nexport function* spawn(\r\n  command: string,\r\n  args?: ReadonlyArray<string>,\r\n  options?: SpawnOptions\r\n): Operation {\r\n  let child = childProcessCross.spawn(\r\n    c(command),\r\n    args || [],\r\n    withDefaults(options)\r\n  );\r\n  child?.stdin?.end();\r\n  return yield resource(child, supervise(child, command, args));\r\n}\r\n\r\nexport function spawnProcess(\r\n  command: string,\r\n  args?: ReadonlyArray<string>,\r\n  options?: SpawnOptions\r\n): ChildProcess {\r\n  const spawned = childProcessCross.spawn(\r\n    c(command),\r\n    args || [],\r\n    withDefaults(options)\r\n  );\r\n  spawned?.stdin?.end();\r\n\r\n  spawned.once(\"exit\", (code, signal) => {\r\n    const safeSignal = signal === null ? 'SIGTERM' : signal;\r\n    try {\r\n      if (process.platform === 'win32') {\r\n        // @ts-ignore\r\n        spawned?.stdout?.end();\r\n        // @ts-ignore\r\n        spawned?.stderr?.end();\r\n        treeKill(spawned.pid, safeSignal, (err: any) => {/*no-op*/});\r\n      } else {\r\n        process.kill(-spawned.pid, safeSignal)\r\n      }\r\n    } catch(e) {\r\n      // do nothing, process is probably already dead\r\n    }\r\n  });\r\n\r\n  return spawned;\r\n}\r\n\r\nexport function* fork(\r\n  module: string,\r\n  args?: ReadonlyArray<string>,\r\n  options?: ForkOptions\r\n): Operation {\r\n  let child = childProcess.fork(module, args, withDefaults(options));\r\n  child?.stdin?.end();\r\n  return yield resource(child, supervise(child, module, args));\r\n}\r\n"],"names":["MainError","Error","constructor","options","message","main","operation","effectionMain","context","mainContext","spawn","interrupt","halt","debug","console","toString","process","on","e","name","error","verbose","stack","exit","exitCode","off","treeKill","TreeKill","supervise","child","command","args","forceKillSignal","throwOnErrorEvent","code","signal","once","join","trim","platform","stdout","end","stderr","pid","err","kill","withDefaults","stdio","detached","cwd","env","npmRunPath","Object","assign","execPath","c","childProcessCross","stdin","resource","spawnProcess","spawned","safeSignal","fork","module","childProcess"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@effection/node/dist/node.cjs.production.min.js b/node_modules/@effection/node/dist/node.cjs.production.min.js
index 1534ca4..5e5f05d 100644
--- a/node_modules/@effection/node/dist/node.cjs.production.min.js
+++ b/node_modules/@effection/node/dist/node.cjs.production.min.js
@@ -1,2 +1,2 @@
-"use strict";var e=require("effection"),r=require("@effection/events"),o=require("child_process");class s extends Error{constructor(e={}){super(e.message||"error"),this.options=e,this.name="EffectionMainError"}}function*t(e,o,s=[]){try{yield r.throwOnErrorEvent(e);let[t]=yield r.once(e,"exit");if(0!==t)throw new Error(`'${(o+s.join(" ")).trim()}' exited with non-zero exit code`)}finally{try{process.kill(-e.pid,"SIGTERM")}catch(e){}}}exports.ChildProcess={__proto__:null,spawn:function*(r,s,n){let i=o.spawn(r,s||[],Object.assign({},n,{detached:!0}));return yield e.resource(i,t(i,r,s))},fork:function*(r,s,n){let i=o.fork(r,s,Object.assign({},n,{detached:!0}));return yield e.resource(i,t(i,r,s))}},exports.MainError=s,exports.main=function(r){return e.main(({context:e,spawn:o})=>{o((function*(){let o=()=>{e.halt()},s=()=>console.debug(e.toString());try{return process.on("SIGINT",o),process.on("SIGTERM",o),process.on("SIGUSR1",s),yield r}catch(e){"EffectionMainError"===e.name?(e.options.message&&console.error(e.options.message),e.options.verbose&&console.error(e.stack),process.exit(e.options.exitCode||-1)):(console.error(e),process.exit(-1))}finally{process.off("SIGINT",o),process.off("SIGTERM",o),process.off("SIGUSR1",s)}}))})};
+"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("effection"),r=require("@effection/events"),o=require("npm-run-path"),n=require("tree-kill"),s=require("cross-spawn"),t=require("child_process");class i extends Error{constructor(e={}){super(e.message||"error"),this.options=e,this.name="EffectionMainError"}}const l=n;function*c(e,o,n=[]){let s="SIGKILL";try{yield r.throwOnErrorEvent(e);let[c,d]=yield r.once(e,"exit");if("string"==typeof d&&(s=d),0!==c)throw new Error(`'${(o+n.join(" ")).trim()}' exited with non-zero exit code`)}finally{try{var t,i;"win32"===process.platform?(null==e||null===(t=e.stdout)||void 0===t||t.end(),null==e||null===(i=e.stderr)||void 0===i||i.end(),l(e.pid,s,e=>{})):process.kill(-e.pid,"SIGTERM")}catch(e){}}}const d=e=>({stdio:"pipe",detached:"win32"!==process.platform,cwd:(null==e?void 0:e.cwd)||process.cwd(),env:o.env({env:Object.assign({},process.env,null==e?void 0:e.env),cwd:(null==e?void 0:e.cwd)||process.cwd(),execPath:process.execPath})}),p=e=>"win32"!==process.platform?e:"npm"===e||"yarn"===e?e+".cmd":e;exports.ChildProcess={__proto__:null,spawn:function*(r,o,n){var t;let i=s.spawn(p(r),o||[],d(n));return null==i||null===(t=i.stdin)||void 0===t||t.end(),yield e.resource(i,c(i,r,o))},spawnProcess:function(e,r,o){var n;const t=s.spawn(p(e),r||[],d(o));return null==t||null===(n=t.stdin)||void 0===n||n.end(),t.once("exit",(e,r)=>{const o=null===r?"SIGTERM":r;try{var n,s;"win32"===process.platform?(null==t||null===(n=t.stdout)||void 0===n||n.end(),null==t||null===(s=t.stderr)||void 0===s||s.end(),l(t.pid,o,e=>{})):process.kill(-t.pid,o)}catch(e){}}),t},fork:function*(r,o,n){var s;let i=t.fork(r,o,d(n));return null==i||null===(s=i.stdin)||void 0===s||s.end(),yield e.resource(i,c(i,r,o))}},exports.MainError=i,exports.main=function(r){return e.main(({context:e,spawn:o})=>{o((function*(){let o=()=>{e.halt()},n=()=>console.debug(e.toString());try{return process.on("SIGINT",o),process.on("SIGTERM",o),process.on("SIGUSR1",n),yield r}catch(e){"EffectionMainError"===e.name?(e.options.message&&console.error(e.options.message),e.options.verbose&&console.error(e.stack),process.exit(e.options.exitCode||-1)):(console.error(e),process.exit(-1))}finally{process.off("SIGINT",o),process.off("SIGTERM",o),process.off("SIGUSR1",n)}}))})};
 //# sourceMappingURL=node.cjs.production.min.js.map
diff --git a/node_modules/@effection/node/dist/node.cjs.production.min.js.map b/node_modules/@effection/node/dist/node.cjs.production.min.js.map
index 9bad1d7..591697c 100644
--- a/node_modules/@effection/node/dist/node.cjs.production.min.js.map
+++ b/node_modules/@effection/node/dist/node.cjs.production.min.js.map
@@ -1 +1 @@
-{"version":3,"file":"node.cjs.production.min.js","sources":["../src/main.ts","../src/child_process.ts"],"sourcesContent":["import { main as effectionMain, Context, Operation } from 'effection';\n\ninterface MainErrorOptions {\n  exitCode?: number;\n  verbose?: boolean;\n  message?: string;\n}\n\nexport class MainError extends Error {\n  name = \"EffectionMainError\"\n\n  constructor(public options: MainErrorOptions = {}) {\n    super(options.message || \"error\");\n  }\n}\n\nexport function main<T>(operation: Operation<T>): Context<T> {\n  return effectionMain(({ context: mainContext, spawn }) => {\n    spawn(function* main() {\n      let interrupt = () => { mainContext.halt(); };\n      let debug = () => console.debug(mainContext.toString());\n      try {\n        process.on('SIGINT', interrupt);\n        process.on('SIGTERM', interrupt);\n        process.on('SIGUSR1', debug);\n        return yield operation;\n      } catch(e) {\n        if(e.name === 'EffectionMainError') {\n          if(e.options.message) {\n            console.error(e.options.message);\n          }\n          if(e.options.verbose) {\n            console.error(e.stack);\n          }\n          process.exit(e.options.exitCode || -1);\n        } else {\n          console.error(e);\n          process.exit(-1);\n        }\n      } finally {\n        process.off('SIGINT', interrupt);\n        process.off('SIGTERM', interrupt);\n        process.off('SIGUSR1', debug);\n      }\n    });\n  });\n}\n","import { Operation, resource } from 'effection';\nimport { once, throwOnErrorEvent } from '@effection/events';\n\nimport * as childProcess from 'child_process';\nimport { SpawnOptions, ForkOptions, ChildProcess } from 'child_process';\n\nexport { ChildProcess } from 'child_process';\n\nfunction *supervise(child: ChildProcess, command: string, args: readonly string[] = []) {\n  // Killing all child processes started by this command is surprisingly\n  // tricky. If a process spawns another processes and we kill the parent,\n  // then the child process is NOT automatically killed. Instead we're using\n  // the `detached` option to force the child into its own process group,\n  // which all of its children in turn will inherit. By sending the signal to\n  // `-pid` rather than `pid`, we are sending it to the entire process group\n  // instead. This will send the signal to all processes started by the child\n  // process.\n  //\n  // More information here: https://unix.stackexchange.com/questions/14815/process-descendants\n  try {\n    yield throwOnErrorEvent(child);\n\n    let [code]: [number] = yield once(child, \"exit\");\n    if(code !== 0) {\n      throw new Error(`'${(command + args.join(' ')).trim()}' exited with non-zero exit code`);\n    }\n  } finally {\n    try {\n      process.kill(-child.pid, \"SIGTERM\")\n    } catch(e) {\n      // do nothing, process is probably already dead\n    }\n  }\n}\n\nexport function *spawn(command: string, args?: ReadonlyArray<string>, options?: SpawnOptions): Operation {\n  let child = childProcess.spawn(command, args || [], Object.assign({}, options, {\n    detached: true,\n  }));\n  return yield resource(child, supervise(child, command, args));\n}\n\nexport function *fork(module: string, args?: ReadonlyArray<string>, options?: ForkOptions): Operation {\n  let child = childProcess.fork(module, args, Object.assign({}, options, {\n    detached: true,\n  }));\n  return yield resource(child, supervise(child, module, args));\n}\n"],"names":["MainError","Error","constructor","options","message","supervise","child","command","args","throwOnErrorEvent","code","once","join","trim","process","kill","pid","e","childProcess","Object","assign","detached","resource","module","operation","effectionMain","context","mainContext","spawn","interrupt","halt","debug","console","toString","on","name","error","verbose","stack","exit","exitCode","off"],"mappings":"wGAQaA,UAAkBC,MAG7BC,YAAmBC,EAA4B,UACvCA,EAAQC,SAAW,sBADRD,YAFZ,sBCDT,SAAUE,EAAUC,EAAqBC,EAAiBC,EAA0B,cAY1EC,oBAAkBH,OAEnBI,SAAwBC,OAAKL,EAAO,WAC7B,IAATI,QACK,IAAIT,WAAWM,EAAUC,EAAKI,KAAK,MAAMC,sDAI/CC,QAAQC,MAAMT,EAAMU,IAAK,WACzB,MAAMC,iDAMZ,UAAuBV,EAAiBC,EAA8BL,OAChEG,EAAQY,QAAmBX,EAASC,GAAQ,GAAIW,OAAOC,OAAO,GAAIjB,EAAS,CAC7EkB,UAAU,kBAECC,WAAShB,EAAOD,EAAUC,EAAOC,EAASC,UAGzD,UAAsBe,EAAgBf,EAA8BL,OAC9DG,EAAQY,OAAkBK,EAAQf,EAAMW,OAAOC,OAAO,GAAIjB,EAAS,CACrEkB,UAAU,kBAECC,WAAShB,EAAOD,EAAUC,EAAOiB,EAAQf,gDD9BhCgB,UACfC,OAAc,EAAGC,QAASC,EAAaC,MAAAA,MAC5CA,GAAM,gBACAC,EAAY,KAAQF,EAAYG,QAChCC,EAAQ,IAAMC,QAAQD,MAAMJ,EAAYM,uBAE1CnB,QAAQoB,GAAG,SAAUL,GACrBf,QAAQoB,GAAG,UAAWL,GACtBf,QAAQoB,GAAG,UAAWH,SACTP,EACb,MAAMP,GACQ,uBAAXA,EAAEkB,MACAlB,EAAEd,QAAQC,SACX4B,QAAQI,MAAMnB,EAAEd,QAAQC,SAEvBa,EAAEd,QAAQkC,SACXL,QAAQI,MAAMnB,EAAEqB,OAElBxB,QAAQyB,KAAKtB,EAAEd,QAAQqC,WAAa,KAEpCR,QAAQI,MAAMnB,GACdH,QAAQyB,MAAM,YAGhBzB,QAAQ2B,IAAI,SAAUZ,GACtBf,QAAQ2B,IAAI,UAAWZ,GACvBf,QAAQ2B,IAAI,UAAWV"}
\ No newline at end of file
+{"version":3,"file":"node.cjs.production.min.js","sources":["../src/main.ts","../src/child_process.ts"],"sourcesContent":["import { main as effectionMain, Context, Operation } from 'effection';\r\n\r\ninterface MainErrorOptions {\r\n  exitCode?: number;\r\n  verbose?: boolean;\r\n  message?: string;\r\n}\r\n\r\nexport class MainError extends Error {\r\n  name = \"EffectionMainError\"\r\n\r\n  constructor(public options: MainErrorOptions = {}) {\r\n    super(options.message || \"error\");\r\n  }\r\n}\r\n\r\nexport function main<T>(operation: Operation<T>): Context<T> {\r\n  return effectionMain(({ context: mainContext, spawn }) => {\r\n    spawn(function* main() {\r\n      let interrupt = () => { mainContext.halt(); };\r\n      let debug = () => console.debug(mainContext.toString());\r\n      try {\r\n        process.on('SIGINT', interrupt);\r\n        process.on('SIGTERM', interrupt);\r\n        process.on('SIGUSR1', debug);\r\n        return yield operation;\r\n      } catch(e) {\r\n        if(e.name === 'EffectionMainError') {\r\n          if(e.options.message) {\r\n            console.error(e.options.message);\r\n          }\r\n          if(e.options.verbose) {\r\n            console.error(e.stack);\r\n          }\r\n          process.exit(e.options.exitCode || -1);\r\n        } else {\r\n          console.error(e);\r\n          process.exit(-1);\r\n        }\r\n      } finally {\r\n        process.off('SIGINT', interrupt);\r\n        process.off('SIGTERM', interrupt);\r\n        process.off('SIGUSR1', debug);\r\n      }\r\n    });\r\n  });\r\n}\r\n","import { Operation, resource } from \"effection\";\r\nimport { once, throwOnErrorEvent } from \"@effection/events\";\r\n\r\nimport * as npmRunPath from \"npm-run-path\";\r\nimport * as TreeKill from \"tree-kill\";\r\nconst treeKill: any = TreeKill;\r\nimport * as childProcessCross from \"cross-spawn\";\r\nimport * as childProcess from \"child_process\";\r\nimport { SpawnOptions, ForkOptions, ChildProcess } from \"child_process\";\r\n\r\nexport { ChildProcess } from \"child_process\";\r\n\r\nfunction* supervise(\r\n  child: ChildProcess,\r\n  command: string,\r\n  args: readonly string[] = []\r\n) {\r\n  let forceKillSignal: string = \"SIGKILL\"\r\n  // Killing all child processes started by this command is surprisingly\r\n  // tricky. If a process spawns another processes and we kill the parent,\r\n  // then the child process is NOT automatically killed. Instead we're using\r\n  // the `detached` option to force the child into its own process group,\r\n  // which all of its children in turn will inherit. By sending the signal to\r\n  // `-pid` rather than `pid`, we are sending it to the entire process group\r\n  // instead. This will send the signal to all processes started by the child\r\n  // process.\r\n  //\r\n  // More information here: https://unix.stackexchange.com/questions/14815/process-descendants\r\n  // Windows is even more tricky as it doesn't have the process groups and\r\n  // doesn't have signals. We resort to `treeKill` which does not gracefully\r\n  // shut down the processes, but it is the best we have?\r\n  try {\r\n    yield throwOnErrorEvent(child);\r\n    let [code, signal]: [number, any] = yield once(child, \"exit\");\r\n    if (typeof signal === \"string\") forceKillSignal = signal\r\n    if (code !== 0) {\r\n      throw new Error(\r\n        `'${(command + args.join(\" \")).trim()}' exited with non-zero exit code`\r\n      );\r\n    }\r\n  } finally {\r\n    try {\r\n      if (process.platform === 'win32') {\r\n        // @ts-ignore\r\n        child?.stdout?.end();\r\n        // @ts-ignore\r\n        child?.stderr?.end();\r\n        treeKill(child.pid, forceKillSignal, (err: any) => {/*no-op*/});\r\n      } else {\r\n        process.kill(-child.pid, \"SIGTERM\")\r\n      }\r\n    } catch(e) {\r\n      // do nothing, process is probably already dead\r\n    }\r\n  }\r\n}\r\n\r\nconst withDefaults = (options: SpawnOptions | undefined): SpawnOptions => {\r\n  return {\r\n    // When windows shell is true, it runs with cmd.exe by default, but\r\n    // node has trouble with PATHEXT and exe. It can't run exe directly for example.\r\n    // `cross-spawn` handles running it with the shell in windows if needed.\r\n    // Neither mac nor linux need shell and we run it detached.\r\n    // shell: ~false,\r\n    // With stdio as pipe, windows gets stuck where neither the child nor the\r\n    // parent wants to close the stream, so we call it ourselves in the exit event.\r\n    stdio: \"pipe\",\r\n    // We lose exit information and events if this is detached in windows\r\n    // and it opens a window in windows+powershell.\r\n    detached: process.platform === \"win32\" ? false : true,\r\n    cwd: options?.cwd || process.cwd(),\r\n    env: npmRunPath.env({\r\n      env: Object.assign({}, process.env, options?.env),\r\n      cwd: options?.cwd || process.cwd(),\r\n      execPath: process.execPath,\r\n    }),\r\n  };\r\n};\r\n\r\n// Windows can't run exe through the child_process so it creates\r\n// these .cmd files that can instead be run. Adjust for it here.\r\nconst c = (command: string) => {\r\n  if (process.platform !== \"win32\") return command;\r\n  if (command === \"npm\" || command === \"yarn\") {\r\n    return `${command}.cmd`;\r\n  } else {\r\n    return command;\r\n  }\r\n};\r\n\r\nexport function* spawn(\r\n  command: string,\r\n  args?: ReadonlyArray<string>,\r\n  options?: SpawnOptions\r\n): Operation {\r\n  let child = childProcessCross.spawn(\r\n    c(command),\r\n    args || [],\r\n    withDefaults(options)\r\n  );\r\n  child?.stdin?.end();\r\n  return yield resource(child, supervise(child, command, args));\r\n}\r\n\r\nexport function spawnProcess(\r\n  command: string,\r\n  args?: ReadonlyArray<string>,\r\n  options?: SpawnOptions\r\n): ChildProcess {\r\n  const spawned = childProcessCross.spawn(\r\n    c(command),\r\n    args || [],\r\n    withDefaults(options)\r\n  );\r\n  spawned?.stdin?.end();\r\n\r\n  spawned.once(\"exit\", (code, signal) => {\r\n    const safeSignal = signal === null ? 'SIGTERM' : signal;\r\n    try {\r\n      if (process.platform === 'win32') {\r\n        // @ts-ignore\r\n        spawned?.stdout?.end();\r\n        // @ts-ignore\r\n        spawned?.stderr?.end();\r\n        treeKill(spawned.pid, safeSignal, (err: any) => {/*no-op*/});\r\n      } else {\r\n        process.kill(-spawned.pid, safeSignal)\r\n      }\r\n    } catch(e) {\r\n      // do nothing, process is probably already dead\r\n    }\r\n  });\r\n\r\n  return spawned;\r\n}\r\n\r\nexport function* fork(\r\n  module: string,\r\n  args?: ReadonlyArray<string>,\r\n  options?: ForkOptions\r\n): Operation {\r\n  let child = childProcess.fork(module, args, withDefaults(options));\r\n  child?.stdin?.end();\r\n  return yield resource(child, supervise(child, module, args));\r\n}\r\n"],"names":["MainError","Error","constructor","options","message","treeKill","TreeKill","supervise","child","command","args","forceKillSignal","throwOnErrorEvent","code","signal","once","join","trim","process","platform","stdout","end","stderr","pid","err","kill","e","withDefaults","stdio","detached","cwd","env","npmRunPath","Object","assign","execPath","c","childProcessCross","stdin","resource","spawned","safeSignal","module","childProcess","operation","effectionMain","context","mainContext","spawn","interrupt","halt","debug","console","toString","on","name","error","verbose","stack","exit","exitCode","off"],"mappings":"yOAQaA,UAAkBC,MAG7BC,YAAmBC,EAA4B,UACvCA,EAAQC,SAAW,sBADRD,YAFZ,sBCJT,MAAME,EAAgBC,EAOtB,SAAUC,EACRC,EACAC,EACAC,EAA0B,QAEtBC,EAA0B,oBAetBC,oBAAkBJ,OACnBK,EAAMC,SAA+BC,OAAKP,EAAO,WAChC,iBAAXM,IAAqBH,EAAkBG,GACrC,IAATD,QACI,IAAIZ,WACHQ,EAAUC,EAAKM,KAAK,MAAMC,8DAKR,UAArBC,QAAQC,UAEVX,MAAAA,aAAAA,EAAOY,uBAAQC,MAEfb,MAAAA,aAAAA,EAAOc,uBAAQD,MACfhB,EAASG,EAAMe,IAAKZ,EAAkBa,QAEtCN,QAAQO,MAAMjB,EAAMe,IAAK,WAE3B,MAAMG,MAMZ,MAAMC,EAAgBxB,IACb,CAQLyB,MAAO,OAGPC,SAA+B,UAArBX,QAAQC,SAClBW,KAAK3B,MAAAA,SAAAA,EAAS2B,MAAOZ,QAAQY,MAC7BC,IAAKC,MAAe,CAClBD,IAAKE,OAAOC,OAAO,GAAIhB,QAAQa,IAAK5B,MAAAA,SAAAA,EAAS4B,KAC7CD,KAAK3B,MAAAA,SAAAA,EAAS2B,MAAOZ,QAAQY,MAC7BK,SAAUjB,QAAQiB,aAOlBC,EAAK3B,GACgB,UAArBS,QAAQC,SAA6BV,EACzB,QAAZA,GAAiC,SAAZA,EACbA,SAEHA,6CAIX,UACEA,EACAC,EACAP,aAEIK,EAAQ6B,QACVD,EAAE3B,GACFC,GAAQ,GACRiB,EAAaxB,WAEfK,MAAAA,aAAAA,EAAO8B,sBAAOjB,YACDkB,WAAS/B,EAAOD,EAAUC,EAAOC,EAASC,kBAGzD,SACED,EACAC,EACAP,eAEMqC,EAAUH,QACdD,EAAE3B,GACFC,GAAQ,GACRiB,EAAaxB,WAEfqC,MAAAA,aAAAA,EAASF,sBAAOjB,MAEhBmB,EAAQzB,KAAK,OAAQ,CAACF,EAAMC,WACpB2B,EAAwB,OAAX3B,EAAkB,UAAYA,cAEtB,UAArBI,QAAQC,UAEVqB,MAAAA,aAAAA,EAASpB,uBAAQC,MAEjBmB,MAAAA,aAAAA,EAASlB,uBAAQD,MACjBhB,EAASmC,EAAQjB,IAAKkB,EAAajB,QAEnCN,QAAQO,MAAMe,EAAQjB,IAAKkB,GAE7B,MAAMf,OAKHc,QAGT,UACEE,EACAhC,EACAP,aAEIK,EAAQmC,OAAkBD,EAAQhC,EAAMiB,EAAaxB,WACzDK,MAAAA,aAAAA,EAAO8B,sBAAOjB,YACDkB,WAAS/B,EAAOD,EAAUC,EAAOkC,EAAQhC,gDD/HhCkC,UACfC,OAAc,EAAGC,QAASC,EAAaC,MAAAA,MAC5CA,GAAM,gBACAC,EAAY,KAAQF,EAAYG,QAChCC,EAAQ,IAAMC,QAAQD,MAAMJ,EAAYM,uBAE1CnC,QAAQoC,GAAG,SAAUL,GACrB/B,QAAQoC,GAAG,UAAWL,GACtB/B,QAAQoC,GAAG,UAAWH,SACTP,EACb,MAAMlB,GACQ,uBAAXA,EAAE6B,MACA7B,EAAEvB,QAAQC,SACXgD,QAAQI,MAAM9B,EAAEvB,QAAQC,SAEvBsB,EAAEvB,QAAQsD,SACXL,QAAQI,MAAM9B,EAAEgC,OAElBxC,QAAQyC,KAAKjC,EAAEvB,QAAQyD,WAAa,KAEpCR,QAAQI,MAAM9B,GACdR,QAAQyC,MAAM,YAGhBzC,QAAQ2C,IAAI,SAAUZ,GACtB/B,QAAQ2C,IAAI,UAAWZ,GACvB/B,QAAQ2C,IAAI,UAAWV"}
\ No newline at end of file
diff --git a/node_modules/@effection/node/package.json b/node_modules/@effection/node/package.json
index 927241e..d7c01e5 100644
--- a/node_modules/@effection/node/package.json
+++ b/node_modules/@effection/node/package.json
@@ -19,8 +19,9 @@
     "mocha": "mocha -r ts-node/register"
   },
   "devDependencies": {
-    "@effection/events": "^0.7.4",
+    "@effection/events": "^0.7.7",
     "@frontside/tsconfig": "0.0.1",
+    "@types/cross-spawn": "^6.0.2",
     "@types/node": "^13.13.2",
     "@types/node-fetch": "^2.5.7",
     "expect": "^25.4.0",
@@ -31,8 +32,11 @@
     "typescript": "^3.7.0"
   },
   "dependencies": {
+    "@effection/events": "^0.7.7",
+    "cross-spawn": "^7.0.3",
     "effection": "^0.7.0",
-    "@effection/events": "^0.7.4"
+    "npm-run-path": "^4.0.1",
+    "tree-kill": "^1.2.2"
   },
   "volta": {
     "node": "12.16.0",
diff --git a/node_modules/@effection/node/src/child_process.ts b/node_modules/@effection/node/src/child_process.ts
index e31a9a9..6f49a67 100644
--- a/node_modules/@effection/node/src/child_process.ts
+++ b/node_modules/@effection/node/src/child_process.ts
@@ -1,12 +1,21 @@
-import { Operation, resource } from 'effection';
-import { once, throwOnErrorEvent } from '@effection/events';
+import { Operation, resource } from "effection";
+import { once, throwOnErrorEvent } from "@effection/events";
 
-import * as childProcess from 'child_process';
-import { SpawnOptions, ForkOptions, ChildProcess } from 'child_process';
+import * as npmRunPath from "npm-run-path";
+import * as TreeKill from "tree-kill";
+const treeKill: any = TreeKill;
+import * as childProcessCross from "cross-spawn";
+import * as childProcess from "child_process";
+import { SpawnOptions, ForkOptions, ChildProcess } from "child_process";
 
-export { ChildProcess } from 'child_process';
+export { ChildProcess } from "child_process";
 
-function *supervise(child: ChildProcess, command: string, args: readonly string[] = []) {
+function* supervise(
+  child: ChildProcess,
+  command: string,
+  args: readonly string[] = []
+) {
+  let forceKillSignal: string = "SIGKILL"
   // Killing all child processes started by this command is surprisingly
   // tricky. If a process spawns another processes and we kill the parent,
   // then the child process is NOT automatically killed. Instead we're using
@@ -17,32 +26,120 @@ function *supervise(child: ChildProcess, command: string, args: readonly string[
   // process.
   //
   // More information here: https://unix.stackexchange.com/questions/14815/process-descendants
+  // Windows is even more tricky as it doesn't have the process groups and
+  // doesn't have signals. We resort to `treeKill` which does not gracefully
+  // shut down the processes, but it is the best we have?
   try {
     yield throwOnErrorEvent(child);
-
-    let [code]: [number] = yield once(child, "exit");
-    if(code !== 0) {
-      throw new Error(`'${(command + args.join(' ')).trim()}' exited with non-zero exit code`);
+    let [code, signal]: [number, any] = yield once(child, "exit");
+    if (typeof signal === "string") forceKillSignal = signal
+    if (code !== 0) {
+      throw new Error(
+        `'${(command + args.join(" ")).trim()}' exited with non-zero exit code`
+      );
     }
   } finally {
     try {
-      process.kill(-child.pid, "SIGTERM")
+      if (process.platform === 'win32') {
+        // @ts-ignore
+        child?.stdout?.end();
+        // @ts-ignore
+        child?.stderr?.end();
+        treeKill(child.pid, forceKillSignal, (err: any) => {/*no-op*/});
+      } else {
+        process.kill(-child.pid, "SIGTERM")
+      }
     } catch(e) {
       // do nothing, process is probably already dead
     }
   }
 }
 
-export function *spawn(command: string, args?: ReadonlyArray<string>, options?: SpawnOptions): Operation {
-  let child = childProcess.spawn(command, args || [], Object.assign({}, options, {
-    detached: true,
-  }));
+const withDefaults = (options: SpawnOptions | undefined): SpawnOptions => {
+  return {
+    // When windows shell is true, it runs with cmd.exe by default, but
+    // node has trouble with PATHEXT and exe. It can't run exe directly for example.
+    // `cross-spawn` handles running it with the shell in windows if needed.
+    // Neither mac nor linux need shell and we run it detached.
+    // shell: ~false,
+    // With stdio as pipe, windows gets stuck where neither the child nor the
+    // parent wants to close the stream, so we call it ourselves in the exit event.
+    stdio: "pipe",
+    // We lose exit information and events if this is detached in windows
+    // and it opens a window in windows+powershell.
+    detached: process.platform === "win32" ? false : true,
+    cwd: options?.cwd || process.cwd(),
+    env: npmRunPath.env({
+      env: Object.assign({}, process.env, options?.env),
+      cwd: options?.cwd || process.cwd(),
+      execPath: process.execPath,
+    }),
+  };
+};
+
+// Windows can't run exe through the child_process so it creates
+// these .cmd files that can instead be run. Adjust for it here.
+const c = (command: string) => {
+  if (process.platform !== "win32") return command;
+  if (command === "npm" || command === "yarn") {
+    return `${command}.cmd`;
+  } else {
+    return command;
+  }
+};
+
+export function* spawn(
+  command: string,
+  args?: ReadonlyArray<string>,
+  options?: SpawnOptions
+): Operation {
+  let child = childProcessCross.spawn(
+    c(command),
+    args || [],
+    withDefaults(options)
+  );
+  child?.stdin?.end();
   return yield resource(child, supervise(child, command, args));
 }
 
-export function *fork(module: string, args?: ReadonlyArray<string>, options?: ForkOptions): Operation {
-  let child = childProcess.fork(module, args, Object.assign({}, options, {
-    detached: true,
-  }));
+export function spawnProcess(
+  command: string,
+  args?: ReadonlyArray<string>,
+  options?: SpawnOptions
+): ChildProcess {
+  const spawned = childProcessCross.spawn(
+    c(command),
+    args || [],
+    withDefaults(options)
+  );
+  spawned?.stdin?.end();
+
+  spawned.once("exit", (code, signal) => {
+    const safeSignal = signal === null ? 'SIGTERM' : signal;
+    try {
+      if (process.platform === 'win32') {
+        // @ts-ignore
+        spawned?.stdout?.end();
+        // @ts-ignore
+        spawned?.stderr?.end();
+        treeKill(spawned.pid, safeSignal, (err: any) => {/*no-op*/});
+      } else {
+        process.kill(-spawned.pid, safeSignal)
+      }
+    } catch(e) {
+      // do nothing, process is probably already dead
+    }
+  });
+
+  return spawned;
+}
+
+export function* fork(
+  module: string,
+  args?: ReadonlyArray<string>,
+  options?: ForkOptions
+): Operation {
+  let child = childProcess.fork(module, args, withDefaults(options));
+  child?.stdin?.end();
   return yield resource(child, supervise(child, module, args));
 }
diff --git a/node_modules/@effection/node/src/index.ts b/node_modules/@effection/node/src/index.ts
index 5c22657..f1c33b6 100644
--- a/node_modules/@effection/node/src/index.ts
+++ b/node_modules/@effection/node/src/index.ts
@@ -1,2 +1,3 @@
 export { main, MainError } from './main';
-export * as ChildProcess from './child_process';
+import * as ChildProcess from './child_process';
+export { ChildProcess }
diff --git a/node_modules/@effection/node/tsconfig.dist.json b/node_modules/@effection/node/tsconfig.dist.json
new file mode 100644
index 0000000..ecaaa52
--- /dev/null
+++ b/node_modules/@effection/node/tsconfig.dist.json
@@ -0,0 +1,8 @@
+{
+  "extends": "./tsconfig",
+  "compilerOptions": {
+    "module": "esnext",
+    "esModuleInterop": true
+  },
+  "exclude": ["./test/*"]
+}
diff --git a/node_modules/@effection/node/tsconfig.json b/node_modules/@effection/node/tsconfig.json
new file mode 100644
index 0000000..835c7c0
--- /dev/null
+++ b/node_modules/@effection/node/tsconfig.json
@@ -0,0 +1,7 @@
+{
+  "extends": "@frontside/tsconfig",
+  "include": [
+    "src/**/*.ts",
+    "test/**/*.ts"
+  ]
+}
