diff --git a/node_modules/@effection/node/dist/child_process.d.ts b/node_modules/@effection/node/dist/child_process.d.ts
index 9c8f7ec..5eb6c29 100644
--- a/node_modules/@effection/node/dist/child_process.d.ts
+++ b/node_modules/@effection/node/dist/child_process.d.ts
@@ -1,6 +1,7 @@
 /// <reference types="node" />
-import { Operation } from 'effection';
-import { SpawnOptions, ForkOptions } from 'child_process';
-export { ChildProcess } from 'child_process';
+import { Operation } from "effection";
+import { SpawnOptions, ForkOptions, ChildProcess } from "child_process";
+export { ChildProcess } from "child_process";
 export declare function spawn(command: string, args?: ReadonlyArray<string>, options?: SpawnOptions): Operation;
+export declare function spawnProcess(command: string, args?: ReadonlyArray<string>, options?: SpawnOptions): ChildProcess;
 export declare function fork(module: string, args?: ReadonlyArray<string>, options?: ForkOptions): Operation;
diff --git a/node_modules/@effection/node/dist/index.d.ts b/node_modules/@effection/node/dist/index.d.ts
index 5c22657..be5de81 100644
--- a/node_modules/@effection/node/dist/index.d.ts
+++ b/node_modules/@effection/node/dist/index.d.ts
@@ -1,2 +1,3 @@
 export { main, MainError } from './main';
-export * as ChildProcess from './child_process';
+import * as ChildProcess from './child_process';
+export { ChildProcess };
diff --git a/node_modules/@effection/node/dist/node.cjs.development.js b/node_modules/@effection/node/dist/node.cjs.development.js
index 73488ab..98e50ec 100644
--- a/node_modules/@effection/node/dist/node.cjs.development.js
+++ b/node_modules/@effection/node/dist/node.cjs.development.js
@@ -1,7 +1,12 @@
 'use strict';
 
+Object.defineProperty(exports, '__esModule', { value: true });
+
 var effection = require('effection');
 var events = require('@effection/events');
+var npmRunPath = require('npm-run-path');
+var TreeKill = require('tree-kill');
+var childProcessCross = require('cross-spawn');
 var childProcess = require('child_process');
 
 class MainError extends Error {
@@ -20,6 +25,7 @@ function main(operation) {
     spawn(function* main() {
       let interrupt = () => {
         mainContext.halt();
+        process.exit();
       };
 
       let debug = () => console.debug(mainContext.toString());
@@ -53,6 +59,8 @@ function main(operation) {
   });
 }
 
+const treeKill = TreeKill;
+
 function* supervise(child, command, args = []) {
   // Killing all child processes started by this command is surprisingly
   // tricky. If a process spawns another processes and we kill the parent,
@@ -69,32 +77,85 @@ function* supervise(child, command, args = []) {
     let [code] = yield events.once(child, "exit");
 
     if (code !== 0) {
-      throw new Error(`'${(command + args.join(' ')).trim()}' exited with non-zero exit code`);
+      throw new Error(`'${(command + args.join(" ")).trim()}' exited with non-zero exit code`);
     }
   } finally {
+    var _child$stdout, _child$stderr;
+
+    // @ts-ignore
+    child === null || child === void 0 ? void 0 : (_child$stdout = child.stdout) === null || _child$stdout === void 0 ? void 0 : _child$stdout.end(); // @ts-ignore
+
+    child === null || child === void 0 ? void 0 : (_child$stderr = child.stderr) === null || _child$stderr === void 0 ? void 0 : _child$stderr.end();
+
     try {
-      process.kill(-child.pid, "SIGTERM");
+      treeKill(child.pid);
     } catch (e) {// do nothing, process is probably already dead
     }
   }
-}
+} // using the shell that invokes will also hide the window on windows
+
+
+const withDefaults = options => {
+  return {
+    shell: process.platform !== 'win32' ? process.env.shell || true : true,
+    stdio: "pipe",
+    detached: process.platform === 'win32' ? false : true,
+    // if we use true than it opens a window in windows+powershell
+    // mac and linux don't need it either
+    env: npmRunPath.env({
+      env: Object.assign({}, process.env, options === null || options === void 0 ? void 0 : options.env),
+      cwd: (options === null || options === void 0 ? void 0 : options.cwd) || process.cwd(),
+      execPath: process.execPath
+    })
+  };
+};
+
+const c = command => {
+  if (process.platform !== 'win32') return command;
+
+  if (command === 'npm' || command === 'yarn') {
+    return `${command}.cmd`;
+  } else {
+    return command;
+  }
+};
 
 function* spawn(command, args, options) {
-  let child = childProcess.spawn(command, args || [], Object.assign({}, options, {
-    detached: true
-  }));
+  var _child$stdin;
+
+  let child = childProcessCross.spawn(c(command), args || [], withDefaults(options));
+  child === null || child === void 0 ? void 0 : (_child$stdin = child.stdin) === null || _child$stdin === void 0 ? void 0 : _child$stdin.end();
   return yield effection.resource(child, supervise(child, command, args));
 }
+function spawnProcess(command, args, options) {
+  var _spawned$stdin;
+
+  const spawned = childProcessCross.spawn(c(command), args || [], withDefaults(options));
+  spawned === null || spawned === void 0 ? void 0 : (_spawned$stdin = spawned.stdin) === null || _spawned$stdin === void 0 ? void 0 : _spawned$stdin.end();
+  spawned.once("exit", () => {
+    var _spawned$stdout, _spawned$stderr;
+
+    // @ts-ignore
+    spawned === null || spawned === void 0 ? void 0 : (_spawned$stdout = spawned.stdout) === null || _spawned$stdout === void 0 ? void 0 : _spawned$stdout.end(); // @ts-ignore
+
+    spawned === null || spawned === void 0 ? void 0 : (_spawned$stderr = spawned.stderr) === null || _spawned$stderr === void 0 ? void 0 : _spawned$stderr.end();
+    treeKill(spawned.pid);
+  });
+  return spawned;
+}
 function* fork(module, args, options) {
-  let child = childProcess.fork(module, args, Object.assign({}, options, {
-    detached: true
-  }));
+  var _child$stdin2;
+
+  let child = childProcess.fork(module, args, withDefaults(options));
+  child === null || child === void 0 ? void 0 : (_child$stdin2 = child.stdin) === null || _child$stdin2 === void 0 ? void 0 : _child$stdin2.end();
+  child.unref();
   return yield effection.resource(child, supervise(child, module, args));
 }
 
 var child_process = {
   __proto__: null,
   spawn: spawn,
+  spawnProcess: spawnProcess,
   fork: fork
 };
 
diff --git a/node_modules/@effection/node/dist/node.cjs.development.js.map b/node_modules/@effection/node/dist/node.cjs.development.js.map
index 84be1d8..5eabade 100644
--- a/node_modules/@effection/node/dist/node.cjs.development.js.map
+++ b/node_modules/@effection/node/dist/node.cjs.development.js.map
@@ -1 +1 @@
-{"version":3,"file":"node.cjs.development.js","sources":["../src/main.ts","../src/child_process.ts"],"sourcesContent":["import { main as effectionMain, Context, Operation } from 'effection';\n\ninterface MainErrorOptions {\n  exitCode?: number;\n  verbose?: boolean;\n  message?: string;\n}\n\nexport class MainError extends Error {\n  name = \"EffectionMainError\"\n\n  constructor(public options: MainErrorOptions = {}) {\n    super(options.message || \"error\");\n  }\n}\n\nexport function main<T>(operation: Operation<T>): Context<T> {\n  return effectionMain(({ context: mainContext, spawn }) => {\n    spawn(function* main() {\n      let interrupt = () => { mainContext.halt(); };\n      let debug = () => console.debug(mainContext.toString());\n      try {\n        process.on('SIGINT', interrupt);\n        process.on('SIGTERM', interrupt);\n        process.on('SIGUSR1', debug);\n        return yield operation;\n      } catch(e) {\n        if(e.name === 'EffectionMainError') {\n          if(e.options.message) {\n            console.error(e.options.message);\n          }\n          if(e.options.verbose) {\n            console.error(e.stack);\n          }\n          process.exit(e.options.exitCode || -1);\n        } else {\n          console.error(e);\n          process.exit(-1);\n        }\n      } finally {\n        process.off('SIGINT', interrupt);\n        process.off('SIGTERM', interrupt);\n        process.off('SIGUSR1', debug);\n      }\n    });\n  });\n}\n","import { Operation, resource } from 'effection';\nimport { once, throwOnErrorEvent } from '@effection/events';\n\nimport * as childProcess from 'child_process';\nimport { SpawnOptions, ForkOptions, ChildProcess } from 'child_process';\n\nexport { ChildProcess } from 'child_process';\n\nfunction *supervise(child: ChildProcess, command: string, args: readonly string[] = []) {\n  // Killing all child processes started by this command is surprisingly\n  // tricky. If a process spawns another processes and we kill the parent,\n  // then the child process is NOT automatically killed. Instead we're using\n  // the `detached` option to force the child into its own process group,\n  // which all of its children in turn will inherit. By sending the signal to\n  // `-pid` rather than `pid`, we are sending it to the entire process group\n  // instead. This will send the signal to all processes started by the child\n  // process.\n  //\n  // More information here: https://unix.stackexchange.com/questions/14815/process-descendants\n  try {\n    yield throwOnErrorEvent(child);\n\n    let [code]: [number] = yield once(child, \"exit\");\n    if(code !== 0) {\n      throw new Error(`'${(command + args.join(' ')).trim()}' exited with non-zero exit code`);\n    }\n  } finally {\n    try {\n      process.kill(-child.pid, \"SIGTERM\")\n    } catch(e) {\n      // do nothing, process is probably already dead\n    }\n  }\n}\n\nexport function *spawn(command: string, args?: ReadonlyArray<string>, options?: SpawnOptions): Operation {\n  let child = childProcess.spawn(command, args || [], Object.assign({}, options, {\n    detached: true,\n  }));\n  return yield resource(child, supervise(child, command, args));\n}\n\nexport function *fork(module: string, args?: ReadonlyArray<string>, options?: ForkOptions): Operation {\n  let child = childProcess.fork(module, args, Object.assign({}, options, {\n    detached: true,\n  }));\n  return yield resource(child, supervise(child, module, args));\n}\n"],"names":["MainError","Error","constructor","options","message","main","operation","effectionMain","context","mainContext","spawn","interrupt","halt","debug","console","toString","process","on","e","name","error","verbose","stack","exit","exitCode","off","supervise","child","command","args","throwOnErrorEvent","code","once","join","trim","kill","pid","childProcess","Object","assign","detached","resource","fork","module"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"node.cjs.development.js","sources":["../src/main.ts","../src/child_process.ts"],"sourcesContent":["import { main as effectionMain, Context, Operation } from 'effection';\r\n\r\ninterface MainErrorOptions {\r\n  exitCode?: number;\r\n  verbose?: boolean;\r\n  message?: string;\r\n}\r\n\r\nexport class MainError extends Error {\r\n  name = \"EffectionMainError\"\r\n\r\n  constructor(public options: MainErrorOptions = {}) {\r\n    super(options.message || \"error\");\r\n  }\r\n}\r\n\r\nexport function main<T>(operation: Operation<T>): Context<T> {\r\n  return effectionMain(({ context: mainContext, spawn }) => {\r\n    spawn(function* main() {\r\n      let interrupt = () => { mainContext.halt(); process.exit(); };\r\n      let debug = () => console.debug(mainContext.toString());\r\n      try {\r\n        process.on('SIGINT', interrupt);\r\n        process.on('SIGTERM', interrupt);\r\n        process.on('SIGUSR1', debug);\r\n        return yield operation;\r\n      } catch(e) {\r\n        if(e.name === 'EffectionMainError') {\r\n          if(e.options.message) {\r\n            console.error(e.options.message);\r\n          }\r\n          if(e.options.verbose) {\r\n            console.error(e.stack);\r\n          }\r\n          process.exit(e.options.exitCode || -1);\r\n        } else {\r\n          console.error(e);\r\n          process.exit(-1);\r\n        }\r\n      } finally {\r\n        process.off('SIGINT', interrupt);\r\n        process.off('SIGTERM', interrupt);\r\n        process.off('SIGUSR1', debug);\r\n      }\r\n    });\r\n  });\r\n}\r\n","import { Operation, resource } from \"effection\";\r\nimport { once, throwOnErrorEvent } from \"@effection/events\";\r\n\r\nimport * as npmRunPath from \"npm-run-path\";\r\nimport * as TreeKill from \"tree-kill\";\r\nconst treeKill: any = TreeKill;\r\nimport * as childProcessCross from \"cross-spawn\";\r\nimport * as childProcess from \"child_process\";\r\nimport { SpawnOptions, ForkOptions, ChildProcess } from \"child_process\";\r\n\r\nexport { ChildProcess } from \"child_process\";\r\n\r\nfunction* supervise(\r\n  child: ChildProcess,\r\n  command: string,\r\n  args: readonly string[] = []\r\n) {\r\n  // Killing all child processes started by this command is surprisingly\r\n  // tricky. If a process spawns another processes and we kill the parent,\r\n  // then the child process is NOT automatically killed. Instead we're using\r\n  // the `detached` option to force the child into its own process group,\r\n  // which all of its children in turn will inherit. By sending the signal to\r\n  // `-pid` rather than `pid`, we are sending it to the entire process group\r\n  // instead. This will send the signal to all processes started by the child\r\n  // process.\r\n  //\r\n  // More information here: https://unix.stackexchange.com/questions/14815/process-descendants\r\n  try {\r\n    yield throwOnErrorEvent(child);\r\n\r\n    let [code]: [number] = yield once(child, \"exit\");\r\n    if (code !== 0) {\r\n      throw new Error(\r\n        `'${(command + args.join(\" \")).trim()}' exited with non-zero exit code`\r\n      );\r\n    }\r\n  } finally {\r\n    // @ts-ignore\r\n    child?.stdout?.end();\r\n    // @ts-ignore\r\n    child?.stderr?.end();\r\n    try {\r\n      treeKill(child.pid)\r\n    } catch (e) {\r\n      // do nothing, process is probably already dead\r\n    }\r\n  }\r\n}\r\n\r\n// using the shell that invokes will also hide the window on windows\r\nconst withDefaults = (options: SpawnOptions | undefined): SpawnOptions => {\r\n  return {\r\n  shell: process.platform !== 'win32' ? process.env.shell || true : true,\r\n  stdio: \"pipe\",\r\n  detached: process.platform === 'win32' ? false : true,\r\n  // if we use true than it opens a window in windows+powershell\r\n  // mac and linux don't need it either\r\n  env: npmRunPath.env({\r\n    env: Object.assign({}, process.env, options?.env),\r\n    cwd: options?.cwd || process.cwd(),\r\n    execPath: process.execPath,\r\n  })}\r\n};\r\n\r\nconst c = (command: string) => {\r\n  if (process.platform !== 'win32') return command\r\n  if (command === 'npm' || command === 'yarn') {\r\n    return `${command}.cmd`\r\n  } else {\r\n    return command\r\n  }\r\n};\r\n\r\nexport function* spawn(\r\n  command: string,\r\n  args?: ReadonlyArray<string>,\r\n  options?: SpawnOptions\r\n): Operation {\r\n  let child = childProcessCross.spawn(\r\n    c(command),\r\n    args || [],\r\n    withDefaults(options)\r\n  );\r\n  child?.stdin?.end();\r\n  return yield resource(child, supervise(child, command, args));\r\n}\r\n\r\nexport function spawnProcess(\r\n  command: string,\r\n  args?: ReadonlyArray<string>,\r\n  options?: SpawnOptions\r\n): ChildProcess {\r\n  const spawned = childProcessCross.spawn(\r\n    c(command),\r\n    args || [],\r\n    withDefaults(options)\r\n  );\r\n  spawned?.stdin?.end();\r\n\r\n  spawned.once(\"exit\", () => {\r\n    // @ts-ignore\r\n    spawned?.stdout?.end();\r\n    // @ts-ignore\r\n    spawned?.stderr?.end();\r\n    treeKill(spawned.pid)\r\n  });\r\n\r\n  return spawned;\r\n}\r\n\r\nexport function* fork(\r\n  module: string,\r\n  args?: ReadonlyArray<string>,\r\n  options?: ForkOptions\r\n): Operation {\r\n  let child = childProcess.fork(\r\n    module,\r\n    args,\r\n    withDefaults(options)\r\n  );\r\n  child?.stdin?.end();\r\n  child.unref();\r\n  return yield resource(child, supervise(child, module, args));\r\n}\r\n"],"names":["MainError","Error","constructor","options","message","main","operation","effectionMain","context","mainContext","spawn","interrupt","halt","process","exit","debug","console","toString","on","e","name","error","verbose","stack","exitCode","off","treeKill","TreeKill","supervise","child","command","args","throwOnErrorEvent","code","once","join","trim","stdout","end","stderr","pid","withDefaults","shell","platform","env","stdio","detached","npmRunPath","Object","assign","cwd","execPath","c","childProcessCross","stdin","resource","spawnProcess","spawned","fork","module","childProcess","unref"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@effection/node/dist/node.cjs.production.min.js b/node_modules/@effection/node/dist/node.cjs.production.min.js
index 1534ca4..7253f2a 100644
--- a/node_modules/@effection/node/dist/node.cjs.production.min.js
+++ b/node_modules/@effection/node/dist/node.cjs.production.min.js
@@ -1,2 +1,2 @@
-"use strict";var e=require("effection"),r=require("@effection/events"),o=require("child_process");class s extends Error{constructor(e={}){super(e.message||"error"),this.options=e,this.name="EffectionMainError"}}function*t(e,o,s=[]){try{yield r.throwOnErrorEvent(e);let[t]=yield r.once(e,"exit");if(0!==t)throw new Error(`'${(o+s.join(" ")).trim()}' exited with non-zero exit code`)}finally{try{process.kill(-e.pid,"SIGTERM")}catch(e){}}}exports.ChildProcess={__proto__:null,spawn:function*(r,s,n){let i=o.spawn(r,s||[],Object.assign({},n,{detached:!0}));return yield e.resource(i,t(i,r,s))},fork:function*(r,s,n){let i=o.fork(r,s,Object.assign({},n,{detached:!0}));return yield e.resource(i,t(i,r,s))}},exports.MainError=s,exports.main=function(r){return e.main(({context:e,spawn:o})=>{o((function*(){let o=()=>{e.halt()},s=()=>console.debug(e.toString());try{return process.on("SIGINT",o),process.on("SIGTERM",o),process.on("SIGUSR1",s),yield r}catch(e){"EffectionMainError"===e.name?(e.options.message&&console.error(e.options.message),e.options.verbose&&console.error(e.stack),process.exit(e.options.exitCode||-1)):(console.error(e),process.exit(-1))}finally{process.off("SIGINT",o),process.off("SIGTERM",o),process.off("SIGUSR1",s)}}))})};
+"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("effection"),r=require("@effection/events"),o=require("npm-run-path"),n=require("tree-kill"),s=require("cross-spawn"),t=require("child_process");class i extends Error{constructor(e={}){super(e.message||"error"),this.options=e,this.name="EffectionMainError"}}const l=n;function*c(e,o,n=[]){try{yield r.throwOnErrorEvent(e);let[i]=yield r.once(e,"exit");if(0!==i)throw new Error(`'${(o+n.join(" ")).trim()}' exited with non-zero exit code`)}finally{var s,t;null==e||null===(s=e.stdout)||void 0===s||s.end(),null==e||null===(t=e.stderr)||void 0===t||t.end();try{l(e.pid)}catch(e){}}}const d=e=>({shell:"win32"!==process.platform&&process.env.shell||!0,stdio:"pipe",detached:"win32"!==process.platform,env:o.env({env:Object.assign({},process.env,null==e?void 0:e.env),cwd:(null==e?void 0:e.cwd)||process.cwd(),execPath:process.execPath})}),u=e=>"win32"!==process.platform?e:"npm"===e||"yarn"===e?e+".cmd":e;exports.ChildProcess={__proto__:null,spawn:function*(r,o,n){var t;let i=s.spawn(u(r),o||[],d(n));return null==i||null===(t=i.stdin)||void 0===t||t.end(),yield e.resource(i,c(i,r,o))},spawnProcess:function(e,r,o){var n;const t=s.spawn(u(e),r||[],d(o));return null==t||null===(n=t.stdin)||void 0===n||n.end(),t.once("exit",()=>{var e,r;null==t||null===(e=t.stdout)||void 0===e||e.end(),null==t||null===(r=t.stderr)||void 0===r||r.end(),l(t.pid)}),t},fork:function*(r,o,n){var s;let i=t.fork(r,o,d(n));return null==i||null===(s=i.stdin)||void 0===s||s.end(),i.unref(),yield e.resource(i,c(i,r,o))}},exports.MainError=i,exports.main=function(r){return e.main(({context:e,spawn:o})=>{o((function*(){let o=()=>{e.halt(),process.exit()},n=()=>console.debug(e.toString());try{return process.on("SIGINT",o),process.on("SIGTERM",o),process.on("SIGUSR1",n),yield r}catch(e){"EffectionMainError"===e.name?(e.options.message&&console.error(e.options.message),e.options.verbose&&console.error(e.stack),process.exit(e.options.exitCode||-1)):(console.error(e),process.exit(-1))}finally{process.off("SIGINT",o),process.off("SIGTERM",o),process.off("SIGUSR1",n)}}))})};
 //# sourceMappingURL=node.cjs.production.min.js.map
diff --git a/node_modules/@effection/node/dist/node.cjs.production.min.js.map b/node_modules/@effection/node/dist/node.cjs.production.min.js.map
index 9bad1d7..0aa6b72 100644
--- a/node_modules/@effection/node/dist/node.cjs.production.min.js.map
+++ b/node_modules/@effection/node/dist/node.cjs.production.min.js.map
@@ -1 +1 @@
-{"version":3,"file":"node.cjs.production.min.js","sources":["../src/main.ts","../src/child_process.ts"],"sourcesContent":["import { main as effectionMain, Context, Operation } from 'effection';\n\ninterface MainErrorOptions {\n  exitCode?: number;\n  verbose?: boolean;\n  message?: string;\n}\n\nexport class MainError extends Error {\n  name = \"EffectionMainError\"\n\n  constructor(public options: MainErrorOptions = {}) {\n    super(options.message || \"error\");\n  }\n}\n\nexport function main<T>(operation: Operation<T>): Context<T> {\n  return effectionMain(({ context: mainContext, spawn }) => {\n    spawn(function* main() {\n      let interrupt = () => { mainContext.halt(); };\n      let debug = () => console.debug(mainContext.toString());\n      try {\n        process.on('SIGINT', interrupt);\n        process.on('SIGTERM', interrupt);\n        process.on('SIGUSR1', debug);\n        return yield operation;\n      } catch(e) {\n        if(e.name === 'EffectionMainError') {\n          if(e.options.message) {\n            console.error(e.options.message);\n          }\n          if(e.options.verbose) {\n            console.error(e.stack);\n          }\n          process.exit(e.options.exitCode || -1);\n        } else {\n          console.error(e);\n          process.exit(-1);\n        }\n      } finally {\n        process.off('SIGINT', interrupt);\n        process.off('SIGTERM', interrupt);\n        process.off('SIGUSR1', debug);\n      }\n    });\n  });\n}\n","import { Operation, resource } from 'effection';\nimport { once, throwOnErrorEvent } from '@effection/events';\n\nimport * as childProcess from 'child_process';\nimport { SpawnOptions, ForkOptions, ChildProcess } from 'child_process';\n\nexport { ChildProcess } from 'child_process';\n\nfunction *supervise(child: ChildProcess, command: string, args: readonly string[] = []) {\n  // Killing all child processes started by this command is surprisingly\n  // tricky. If a process spawns another processes and we kill the parent,\n  // then the child process is NOT automatically killed. Instead we're using\n  // the `detached` option to force the child into its own process group,\n  // which all of its children in turn will inherit. By sending the signal to\n  // `-pid` rather than `pid`, we are sending it to the entire process group\n  // instead. This will send the signal to all processes started by the child\n  // process.\n  //\n  // More information here: https://unix.stackexchange.com/questions/14815/process-descendants\n  try {\n    yield throwOnErrorEvent(child);\n\n    let [code]: [number] = yield once(child, \"exit\");\n    if(code !== 0) {\n      throw new Error(`'${(command + args.join(' ')).trim()}' exited with non-zero exit code`);\n    }\n  } finally {\n    try {\n      process.kill(-child.pid, \"SIGTERM\")\n    } catch(e) {\n      // do nothing, process is probably already dead\n    }\n  }\n}\n\nexport function *spawn(command: string, args?: ReadonlyArray<string>, options?: SpawnOptions): Operation {\n  let child = childProcess.spawn(command, args || [], Object.assign({}, options, {\n    detached: true,\n  }));\n  return yield resource(child, supervise(child, command, args));\n}\n\nexport function *fork(module: string, args?: ReadonlyArray<string>, options?: ForkOptions): Operation {\n  let child = childProcess.fork(module, args, Object.assign({}, options, {\n    detached: true,\n  }));\n  return yield resource(child, supervise(child, module, args));\n}\n"],"names":["MainError","Error","constructor","options","message","supervise","child","command","args","throwOnErrorEvent","code","once","join","trim","process","kill","pid","e","childProcess","Object","assign","detached","resource","module","operation","effectionMain","context","mainContext","spawn","interrupt","halt","debug","console","toString","on","name","error","verbose","stack","exit","exitCode","off"],"mappings":"wGAQaA,UAAkBC,MAG7BC,YAAmBC,EAA4B,UACvCA,EAAQC,SAAW,sBADRD,YAFZ,sBCDT,SAAUE,EAAUC,EAAqBC,EAAiBC,EAA0B,cAY1EC,oBAAkBH,OAEnBI,SAAwBC,OAAKL,EAAO,WAC7B,IAATI,QACK,IAAIT,WAAWM,EAAUC,EAAKI,KAAK,MAAMC,sDAI/CC,QAAQC,MAAMT,EAAMU,IAAK,WACzB,MAAMC,iDAMZ,UAAuBV,EAAiBC,EAA8BL,OAChEG,EAAQY,QAAmBX,EAASC,GAAQ,GAAIW,OAAOC,OAAO,GAAIjB,EAAS,CAC7EkB,UAAU,kBAECC,WAAShB,EAAOD,EAAUC,EAAOC,EAASC,UAGzD,UAAsBe,EAAgBf,EAA8BL,OAC9DG,EAAQY,OAAkBK,EAAQf,EAAMW,OAAOC,OAAO,GAAIjB,EAAS,CACrEkB,UAAU,kBAECC,WAAShB,EAAOD,EAAUC,EAAOiB,EAAQf,gDD9BhCgB,UACfC,OAAc,EAAGC,QAASC,EAAaC,MAAAA,MAC5CA,GAAM,gBACAC,EAAY,KAAQF,EAAYG,QAChCC,EAAQ,IAAMC,QAAQD,MAAMJ,EAAYM,uBAE1CnB,QAAQoB,GAAG,SAAUL,GACrBf,QAAQoB,GAAG,UAAWL,GACtBf,QAAQoB,GAAG,UAAWH,SACTP,EACb,MAAMP,GACQ,uBAAXA,EAAEkB,MACAlB,EAAEd,QAAQC,SACX4B,QAAQI,MAAMnB,EAAEd,QAAQC,SAEvBa,EAAEd,QAAQkC,SACXL,QAAQI,MAAMnB,EAAEqB,OAElBxB,QAAQyB,KAAKtB,EAAEd,QAAQqC,WAAa,KAEpCR,QAAQI,MAAMnB,GACdH,QAAQyB,MAAM,YAGhBzB,QAAQ2B,IAAI,SAAUZ,GACtBf,QAAQ2B,IAAI,UAAWZ,GACvBf,QAAQ2B,IAAI,UAAWV"}
\ No newline at end of file
+{"version":3,"file":"node.cjs.production.min.js","sources":["../src/main.ts","../src/child_process.ts"],"sourcesContent":["import { main as effectionMain, Context, Operation } from 'effection';\r\n\r\ninterface MainErrorOptions {\r\n  exitCode?: number;\r\n  verbose?: boolean;\r\n  message?: string;\r\n}\r\n\r\nexport class MainError extends Error {\r\n  name = \"EffectionMainError\"\r\n\r\n  constructor(public options: MainErrorOptions = {}) {\r\n    super(options.message || \"error\");\r\n  }\r\n}\r\n\r\nexport function main<T>(operation: Operation<T>): Context<T> {\r\n  return effectionMain(({ context: mainContext, spawn }) => {\r\n    spawn(function* main() {\r\n      let interrupt = () => { mainContext.halt(); process.exit(); };\r\n      let debug = () => console.debug(mainContext.toString());\r\n      try {\r\n        process.on('SIGINT', interrupt);\r\n        process.on('SIGTERM', interrupt);\r\n        process.on('SIGUSR1', debug);\r\n        return yield operation;\r\n      } catch(e) {\r\n        if(e.name === 'EffectionMainError') {\r\n          if(e.options.message) {\r\n            console.error(e.options.message);\r\n          }\r\n          if(e.options.verbose) {\r\n            console.error(e.stack);\r\n          }\r\n          process.exit(e.options.exitCode || -1);\r\n        } else {\r\n          console.error(e);\r\n          process.exit(-1);\r\n        }\r\n      } finally {\r\n        process.off('SIGINT', interrupt);\r\n        process.off('SIGTERM', interrupt);\r\n        process.off('SIGUSR1', debug);\r\n      }\r\n    });\r\n  });\r\n}\r\n","import { Operation, resource } from \"effection\";\r\nimport { once, throwOnErrorEvent } from \"@effection/events\";\r\n\r\nimport * as npmRunPath from \"npm-run-path\";\r\nimport * as TreeKill from \"tree-kill\";\r\nconst treeKill: any = TreeKill;\r\nimport * as childProcessCross from \"cross-spawn\";\r\nimport * as childProcess from \"child_process\";\r\nimport { SpawnOptions, ForkOptions, ChildProcess } from \"child_process\";\r\n\r\nexport { ChildProcess } from \"child_process\";\r\n\r\nfunction* supervise(\r\n  child: ChildProcess,\r\n  command: string,\r\n  args: readonly string[] = []\r\n) {\r\n  // Killing all child processes started by this command is surprisingly\r\n  // tricky. If a process spawns another processes and we kill the parent,\r\n  // then the child process is NOT automatically killed. Instead we're using\r\n  // the `detached` option to force the child into its own process group,\r\n  // which all of its children in turn will inherit. By sending the signal to\r\n  // `-pid` rather than `pid`, we are sending it to the entire process group\r\n  // instead. This will send the signal to all processes started by the child\r\n  // process.\r\n  //\r\n  // More information here: https://unix.stackexchange.com/questions/14815/process-descendants\r\n  try {\r\n    yield throwOnErrorEvent(child);\r\n\r\n    let [code]: [number] = yield once(child, \"exit\");\r\n    if (code !== 0) {\r\n      throw new Error(\r\n        `'${(command + args.join(\" \")).trim()}' exited with non-zero exit code`\r\n      );\r\n    }\r\n  } finally {\r\n    // @ts-ignore\r\n    child?.stdout?.end();\r\n    // @ts-ignore\r\n    child?.stderr?.end();\r\n    try {\r\n      treeKill(child.pid)\r\n    } catch (e) {\r\n      // do nothing, process is probably already dead\r\n    }\r\n  }\r\n}\r\n\r\n// using the shell that invokes will also hide the window on windows\r\nconst withDefaults = (options: SpawnOptions | undefined): SpawnOptions => {\r\n  return {\r\n  shell: process.platform !== 'win32' ? process.env.shell || true : true,\r\n  stdio: \"pipe\",\r\n  detached: process.platform === 'win32' ? false : true,\r\n  // if we use true than it opens a window in windows+powershell\r\n  // mac and linux don't need it either\r\n  env: npmRunPath.env({\r\n    env: Object.assign({}, process.env, options?.env),\r\n    cwd: options?.cwd || process.cwd(),\r\n    execPath: process.execPath,\r\n  })}\r\n};\r\n\r\nconst c = (command: string) => {\r\n  if (process.platform !== 'win32') return command\r\n  if (command === 'npm' || command === 'yarn') {\r\n    return `${command}.cmd`\r\n  } else {\r\n    return command\r\n  }\r\n};\r\n\r\nexport function* spawn(\r\n  command: string,\r\n  args?: ReadonlyArray<string>,\r\n  options?: SpawnOptions\r\n): Operation {\r\n  let child = childProcessCross.spawn(\r\n    c(command),\r\n    args || [],\r\n    withDefaults(options)\r\n  );\r\n  child?.stdin?.end();\r\n  return yield resource(child, supervise(child, command, args));\r\n}\r\n\r\nexport function spawnProcess(\r\n  command: string,\r\n  args?: ReadonlyArray<string>,\r\n  options?: SpawnOptions\r\n): ChildProcess {\r\n  const spawned = childProcessCross.spawn(\r\n    c(command),\r\n    args || [],\r\n    withDefaults(options)\r\n  );\r\n  spawned?.stdin?.end();\r\n\r\n  spawned.once(\"exit\", () => {\r\n    // @ts-ignore\r\n    spawned?.stdout?.end();\r\n    // @ts-ignore\r\n    spawned?.stderr?.end();\r\n    treeKill(spawned.pid)\r\n  });\r\n\r\n  return spawned;\r\n}\r\n\r\nexport function* fork(\r\n  module: string,\r\n  args?: ReadonlyArray<string>,\r\n  options?: ForkOptions\r\n): Operation {\r\n  let child = childProcess.fork(\r\n    module,\r\n    args,\r\n    withDefaults(options)\r\n  );\r\n  child?.stdin?.end();\r\n  child.unref();\r\n  return yield resource(child, supervise(child, module, args));\r\n}\r\n"],"names":["MainError","Error","constructor","options","message","treeKill","TreeKill","supervise","child","command","args","throwOnErrorEvent","code","once","join","trim","stdout","end","stderr","pid","e","withDefaults","shell","process","platform","env","stdio","detached","npmRunPath","Object","assign","cwd","execPath","c","childProcessCross","stdin","resource","spawned","module","childProcess","unref","operation","effectionMain","context","mainContext","spawn","interrupt","halt","exit","debug","console","toString","on","name","error","verbose","stack","exitCode","off"],"mappings":"yOAQaA,UAAkBC,MAG7BC,YAAmBC,EAA4B,UACvCA,EAAQC,SAAW,sBADRD,YAFZ,sBCJT,MAAME,EAAgBC,EAOtB,SAAUC,EACRC,EACAC,EACAC,EAA0B,cAalBC,oBAAkBH,OAEnBI,SAAwBC,OAAKL,EAAO,WAC5B,IAATI,QACI,IAAIX,WACHQ,EAAUC,EAAKI,KAAK,MAAMC,0DAKnCP,MAAAA,aAAAA,EAAOQ,uBAAQC,MAEfT,MAAAA,aAAAA,EAAOU,uBAAQD,UAEbZ,EAASG,EAAMW,KACf,MAAOC,MAOb,MAAMC,EAAgBlB,IACb,CACPmB,MAA4B,UAArBC,QAAQC,UAAuBD,QAAQE,IAAIH,QAAgB,EAClEI,MAAO,OACPC,SAA+B,UAArBJ,QAAQC,SAGlBC,IAAKG,MAAe,CAClBH,IAAKI,OAAOC,OAAO,GAAIP,QAAQE,IAAKtB,MAAAA,SAAAA,EAASsB,KAC7CM,KAAK5B,MAAAA,SAAAA,EAAS4B,MAAOR,QAAQQ,MAC7BC,SAAUT,QAAQS,aAIhBC,EAAKxB,GACgB,UAArBc,QAAQC,SAA6Bf,EACzB,QAAZA,GAAiC,SAAZA,EACbA,SAEHA,6CAIX,UACEA,EACAC,EACAP,aAEIK,EAAQ0B,QACVD,EAAExB,GACFC,GAAQ,GACRW,EAAalB,WAEfK,MAAAA,aAAAA,EAAO2B,sBAAOlB,YACDmB,WAAS5B,EAAOD,EAAUC,EAAOC,EAASC,kBAGzD,SACED,EACAC,EACAP,eAEMkC,EAAUH,QACdD,EAAExB,GACFC,GAAQ,GACRW,EAAalB,WAEfkC,MAAAA,aAAAA,EAASF,sBAAOlB,MAEhBoB,EAAQxB,KAAK,OAAQ,aAEnBwB,MAAAA,aAAAA,EAASrB,uBAAQC,MAEjBoB,MAAAA,aAAAA,EAASnB,uBAAQD,MACjBZ,EAASgC,EAAQlB,OAGZkB,QAGT,UACEC,EACA5B,EACAP,aAEIK,EAAQ+B,OACVD,EACA5B,EACAW,EAAalB,WAEfK,MAAAA,aAAAA,EAAO2B,sBAAOlB,MACdT,EAAMgC,cACOJ,WAAS5B,EAAOD,EAAUC,EAAO8B,EAAQ5B,gDD1GhC+B,UACfC,OAAc,EAAGC,QAASC,EAAaC,MAAAA,MAC5CA,GAAM,gBACAC,EAAY,KAAQF,EAAYG,OAAQxB,QAAQyB,QAChDC,EAAQ,IAAMC,QAAQD,MAAML,EAAYO,uBAE1C5B,QAAQ6B,GAAG,SAAUN,GACrBvB,QAAQ6B,GAAG,UAAWN,GACtBvB,QAAQ6B,GAAG,UAAWH,SACTR,EACb,MAAMrB,GACQ,uBAAXA,EAAEiC,MACAjC,EAAEjB,QAAQC,SACX8C,QAAQI,MAAMlC,EAAEjB,QAAQC,SAEvBgB,EAAEjB,QAAQoD,SACXL,QAAQI,MAAMlC,EAAEoC,OAElBjC,QAAQyB,KAAK5B,EAAEjB,QAAQsD,WAAa,KAEpCP,QAAQI,MAAMlC,GACdG,QAAQyB,MAAM,YAGhBzB,QAAQmC,IAAI,SAAUZ,GACtBvB,QAAQmC,IAAI,UAAWZ,GACvBvB,QAAQmC,IAAI,UAAWT"}
\ No newline at end of file
diff --git a/node_modules/@effection/node/package.json b/node_modules/@effection/node/package.json
index 927241e..d7c01e5 100644
--- a/node_modules/@effection/node/package.json
+++ b/node_modules/@effection/node/package.json
@@ -19,8 +19,9 @@
     "mocha": "mocha -r ts-node/register"
   },
   "devDependencies": {
-    "@effection/events": "^0.7.4",
+    "@effection/events": "^0.7.7",
     "@frontside/tsconfig": "0.0.1",
+    "@types/cross-spawn": "^6.0.2",
     "@types/node": "^13.13.2",
     "@types/node-fetch": "^2.5.7",
     "expect": "^25.4.0",
@@ -31,8 +32,11 @@
     "typescript": "^3.7.0"
   },
   "dependencies": {
+    "@effection/events": "^0.7.7",
+    "cross-spawn": "^7.0.3",
     "effection": "^0.7.0",
-    "@effection/events": "^0.7.4"
+    "npm-run-path": "^4.0.1",
+    "tree-kill": "^1.2.2"
   },
   "volta": {
     "node": "12.16.0",
diff --git a/node_modules/@effection/node/src/child_process.ts b/node_modules/@effection/node/src/child_process.ts
index e31a9a9..3a252b3 100644
--- a/node_modules/@effection/node/src/child_process.ts
+++ b/node_modules/@effection/node/src/child_process.ts
@@ -1,12 +1,20 @@
-import { Operation, resource } from 'effection';
-import { once, throwOnErrorEvent } from '@effection/events';
+import { Operation, resource } from "effection";
+import { once, throwOnErrorEvent } from "@effection/events";
 
-import * as childProcess from 'child_process';
-import { SpawnOptions, ForkOptions, ChildProcess } from 'child_process';
+import * as npmRunPath from "npm-run-path";
+import * as TreeKill from "tree-kill";
+const treeKill: any = TreeKill;
+import * as childProcessCross from "cross-spawn";
+import * as childProcess from "child_process";
+import { SpawnOptions, ForkOptions, ChildProcess } from "child_process";
 
-export { ChildProcess } from 'child_process';
+export { ChildProcess } from "child_process";
 
-function *supervise(child: ChildProcess, command: string, args: readonly string[] = []) {
+function* supervise(
+  child: ChildProcess,
+  command: string,
+  args: readonly string[] = []
+) {
   // Killing all child processes started by this command is surprisingly
   // tricky. If a process spawns another processes and we kill the parent,
   // then the child process is NOT automatically killed. Instead we're using
@@ -21,28 +29,96 @@ function *supervise(child: ChildProcess, command: string, args: readonly string[
     yield throwOnErrorEvent(child);
 
     let [code]: [number] = yield once(child, "exit");
-    if(code !== 0) {
-      throw new Error(`'${(command + args.join(' ')).trim()}' exited with non-zero exit code`);
+    if (code !== 0) {
+      throw new Error(
+        `'${(command + args.join(" ")).trim()}' exited with non-zero exit code`
+      );
     }
   } finally {
+    // @ts-ignore
+    child?.stdout?.end();
+    // @ts-ignore
+    child?.stderr?.end();
     try {
-      process.kill(-child.pid, "SIGTERM")
-    } catch(e) {
+      treeKill(child.pid)
+    } catch (e) {
       // do nothing, process is probably already dead
     }
   }
 }
 
-export function *spawn(command: string, args?: ReadonlyArray<string>, options?: SpawnOptions): Operation {
-  let child = childProcess.spawn(command, args || [], Object.assign({}, options, {
-    detached: true,
-  }));
+// using the shell that invokes will also hide the window on windows
+const withDefaults = (options: SpawnOptions | undefined): SpawnOptions => {
+  return {
+  shell: process.platform !== 'win32' ? process.env.shell || true : true,
+  stdio: "pipe",
+  detached: process.platform === 'win32' ? false : true,
+  // if we use true than it opens a window in windows+powershell
+  // mac and linux don't need it either
+  env: npmRunPath.env({
+    env: Object.assign({}, process.env, options?.env),
+    cwd: options?.cwd || process.cwd(),
+    execPath: process.execPath,
+  })}
+};
+
+const c = (command: string) => {
+  if (process.platform !== 'win32') return command
+  if (command === 'npm' || command === 'yarn') {
+    return `${command}.cmd`
+  } else {
+    return command
+  }
+};
+
+export function* spawn(
+  command: string,
+  args?: ReadonlyArray<string>,
+  options?: SpawnOptions
+): Operation {
+  let child = childProcessCross.spawn(
+    c(command),
+    args || [],
+    withDefaults(options)
+  );
+  child?.stdin?.end();
   return yield resource(child, supervise(child, command, args));
 }
 
-export function *fork(module: string, args?: ReadonlyArray<string>, options?: ForkOptions): Operation {
-  let child = childProcess.fork(module, args, Object.assign({}, options, {
-    detached: true,
-  }));
+export function spawnProcess(
+  command: string,
+  args?: ReadonlyArray<string>,
+  options?: SpawnOptions
+): ChildProcess {
+  const spawned = childProcessCross.spawn(
+    c(command),
+    args || [],
+    withDefaults(options)
+  );
+  spawned?.stdin?.end();
+
+  spawned.once("exit", () => {
+    // @ts-ignore
+    spawned?.stdout?.end();
+    // @ts-ignore
+    spawned?.stderr?.end();
+    treeKill(spawned.pid)
+  });
+
+  return spawned;
+}
+
+export function* fork(
+  module: string,
+  args?: ReadonlyArray<string>,
+  options?: ForkOptions
+): Operation {
+  let child = childProcess.fork(
+    module,
+    args,
+    withDefaults(options)
+  );
+  child?.stdin?.end();
+  child.unref();
   return yield resource(child, supervise(child, module, args));
 }
diff --git a/node_modules/@effection/node/src/index.ts b/node_modules/@effection/node/src/index.ts
index 5c22657..f1c33b6 100644
--- a/node_modules/@effection/node/src/index.ts
+++ b/node_modules/@effection/node/src/index.ts
@@ -1,2 +1,3 @@
 export { main, MainError } from './main';
-export * as ChildProcess from './child_process';
+import * as ChildProcess from './child_process';
+export { ChildProcess }
diff --git a/node_modules/@effection/node/src/main.ts b/node_modules/@effection/node/src/main.ts
index f9584c7..f9ce39a 100644
--- a/node_modules/@effection/node/src/main.ts
+++ b/node_modules/@effection/node/src/main.ts
@@ -17,7 +17,7 @@ export class MainError extends Error {
 export function main<T>(operation: Operation<T>): Context<T> {
   return effectionMain(({ context: mainContext, spawn }) => {
     spawn(function* main() {
-      let interrupt = () => { mainContext.halt(); };
+      let interrupt = () => { mainContext.halt(); process.exit(); };
       let debug = () => console.debug(mainContext.toString());
       try {
         process.on('SIGINT', interrupt);
diff --git a/node_modules/@effection/node/tsconfig.dist.json b/node_modules/@effection/node/tsconfig.dist.json
new file mode 100644
index 0000000..ecaaa52
--- /dev/null
+++ b/node_modules/@effection/node/tsconfig.dist.json
@@ -0,0 +1,8 @@
+{
+  "extends": "./tsconfig",
+  "compilerOptions": {
+    "module": "esnext",
+    "esModuleInterop": true
+  },
+  "exclude": ["./test/*"]
+}
diff --git a/node_modules/@effection/node/tsconfig.json b/node_modules/@effection/node/tsconfig.json
new file mode 100644
index 0000000..835c7c0
--- /dev/null
+++ b/node_modules/@effection/node/tsconfig.json
@@ -0,0 +1,7 @@
+{
+  "extends": "@frontside/tsconfig",
+  "include": [
+    "src/**/*.ts",
+    "test/**/*.ts"
+  ]
+}
