diff --git a/node_modules/@effection/node/dist/child_process.d.ts b/node_modules/@effection/node/dist/child_process.d.ts
index 9c8f7ec..5eb6c29 100644
--- a/node_modules/@effection/node/dist/child_process.d.ts
+++ b/node_modules/@effection/node/dist/child_process.d.ts
@@ -1,6 +1,7 @@
 /// <reference types="node" />
-import { Operation } from 'effection';
-import { SpawnOptions, ForkOptions } from 'child_process';
-export { ChildProcess } from 'child_process';
+import { Operation } from "effection";
+import { SpawnOptions, ForkOptions, ChildProcess } from "child_process";
+export { ChildProcess } from "child_process";
 export declare function spawn(command: string, args?: ReadonlyArray<string>, options?: SpawnOptions): Operation;
+export declare function spawnProcess(command: string, args?: ReadonlyArray<string>, options?: SpawnOptions): ChildProcess;
 export declare function fork(module: string, args?: ReadonlyArray<string>, options?: ForkOptions): Operation;
diff --git a/node_modules/@effection/node/dist/index.d.ts b/node_modules/@effection/node/dist/index.d.ts
index 5c22657..be5de81 100644
--- a/node_modules/@effection/node/dist/index.d.ts
+++ b/node_modules/@effection/node/dist/index.d.ts
@@ -1,2 +1,3 @@
 export { main, MainError } from './main';
-export * as ChildProcess from './child_process';
+import * as ChildProcess from './child_process';
+export { ChildProcess };
diff --git a/node_modules/@effection/node/dist/node.cjs.development.js b/node_modules/@effection/node/dist/node.cjs.development.js
index 73488ab..c3c5897 100644
--- a/node_modules/@effection/node/dist/node.cjs.development.js
+++ b/node_modules/@effection/node/dist/node.cjs.development.js
@@ -1,7 +1,12 @@
 'use strict';
 
+Object.defineProperty(exports, '__esModule', { value: true });
+
 var effection = require('effection');
 var events = require('@effection/events');
+var npmRunPath = require('npm-run-path');
+var TreeKill = require('tree-kill');
+var childProcessCross = require('cross-spawn');
 var childProcess = require('child_process');
 
 class MainError extends Error {
@@ -53,6 +58,26 @@ function main(operation) {
   });
 }
 
+function _extends() {
+  _extends = Object.assign || function (target) {
+    for (var i = 1; i < arguments.length; i++) {
+      var source = arguments[i];
+
+      for (var key in source) {
+        if (Object.prototype.hasOwnProperty.call(source, key)) {
+          target[key] = source[key];
+        }
+      }
+    }
+
+    return target;
+  };
+
+  return _extends.apply(this, arguments);
+}
+
+const treeKill = TreeKill;
+
 function* supervise(child, command, args = []) {
   // Killing all child processes started by this command is surprisingly
   // tricky. If a process spawns another processes and we kill the parent,
@@ -69,32 +94,98 @@ function* supervise(child, command, args = []) {
     let [code] = yield events.once(child, "exit");
 
     if (code !== 0) {
-      throw new Error(`'${(command + args.join(' ')).trim()}' exited with non-zero exit code`);
+      throw new Error(`'${(command + args.join(" ")).trim()}' exited with non-zero exit code`);
     }
   } finally {
     try {
-      process.kill(-child.pid, "SIGTERM");
+      if (process.platform === 'win32') {
+        var _child$stdout, _child$stderr;
+
+        // @ts-ignore
+        child === null || child === void 0 ? void 0 : (_child$stdout = child.stdout) === null || _child$stdout === void 0 ? void 0 : _child$stdout.end(); // @ts-ignore
+
+        child === null || child === void 0 ? void 0 : (_child$stderr = child.stderr) === null || _child$stderr === void 0 ? void 0 : _child$stderr.end();
+        treeKill(child.pid, "SIGTERM", err => console.error(`supervised tree-kill of process ${child.pid} failed.`, err));
+      } else {
+        process.kill(-child.pid, "SIGTERM");
+      }
     } catch (e) {// do nothing, process is probably already dead
     }
   }
-}
+} // using the shell that invokes will also hide the window on windows
+
+
+const withDefaults = options => {
+  return _extends({}, process.platform === "win32" ? {} : {
+    shell: true
+  }, {
+    stdio: "pipe",
+    // we lose exit information and events if this is
+    // detached in windows
+    detached: process.platform === "win32" ? false : true,
+    cwd: (options === null || options === void 0 ? void 0 : options.cwd) || process.cwd(),
+    // if we use true than it opens a window in windows+powershell
+    // mac and linux don't need it either
+    env: npmRunPath.env({
+      env: Object.assign({}, process.env, options === null || options === void 0 ? void 0 : options.env),
+      cwd: (options === null || options === void 0 ? void 0 : options.cwd) || process.cwd(),
+      execPath: process.execPath
+    })
+  });
+};
+
+const c = command => {
+  if (process.platform !== "win32") return command;
+
+  if (command === "npm" || command === "yarn") {
+    return `${command}.cmd`;
+  } else {
+    return command;
+  }
+};
 
 function* spawn(command, args, options) {
-  let child = childProcess.spawn(command, args || [], Object.assign({}, options, {
-    detached: true
-  }));
+  var _child$stdin;
+
+  let child = childProcessCross.spawn(c(command), args || [], withDefaults(options));
+  child === null || child === void 0 ? void 0 : (_child$stdin = child.stdin) === null || _child$stdin === void 0 ? void 0 : _child$stdin.end();
   return yield effection.resource(child, supervise(child, command, args));
 }
+function spawnProcess(command, args, options) {
+  var _spawned$stdin;
+
+  const spawned = childProcessCross.spawn(c(command), args || [], withDefaults(options));
+  spawned === null || spawned === void 0 ? void 0 : (_spawned$stdin = spawned.stdin) === null || _spawned$stdin === void 0 ? void 0 : _spawned$stdin.end();
+  spawned.once("exit", () => {
+    try {
+      if (process.platform === 'win32') {
+        var _child, _child$stdout2, _child2, _child2$stderr;
+
+        // @ts-ignore
+        (_child = child) === null || _child === void 0 ? void 0 : (_child$stdout2 = _child.stdout) === null || _child$stdout2 === void 0 ? void 0 : _child$stdout2.end(); // @ts-ignore
+
+        (_child2 = child) === null || _child2 === void 0 ? void 0 : (_child2$stderr = _child2.stderr) === null || _child2$stderr === void 0 ? void 0 : _child2$stderr.end();
+        treeKill(spawned.pid, "SIGTERM", err => console.error(`unsupervised tree-kill of process ${spawned.pid} failed.`, err));
+      } else {
+        process.kill(-spawned.pid, "SIGTERM");
+      }
+    } catch (e) {// do nothing, process is probably already dead
+    }
+  });
+  return spawned;
+}
 function* fork(module, args, options) {
-  let child = childProcess.fork(module, args, Object.assign({}, options, {
-    detached: true
-  }));
+  var _child$stdin2;
+
+  let child = childProcess.fork(module, args, withDefaults(options));
+  child === null || child === void 0 ? void 0 : (_child$stdin2 = child.stdin) === null || _child$stdin2 === void 0 ? void 0 : _child$stdin2.end();
   return yield effection.resource(child, supervise(child, module, args));
 }
 
 var child_process = {
   __proto__: null,
   spawn: spawn,
+  spawnProcess: spawnProcess,
   fork: fork
 };
 
diff --git a/node_modules/@effection/node/dist/node.cjs.development.js.map b/node_modules/@effection/node/dist/node.cjs.development.js.map
index 84be1d8..1c103a1 100644
--- a/node_modules/@effection/node/dist/node.cjs.development.js.map
+++ b/node_modules/@effection/node/dist/node.cjs.development.js.map
@@ -1 +1 @@
-{"version":3,"file":"node.cjs.development.js","sources":["../src/main.ts","../src/child_process.ts"],"sourcesContent":["import { main as effectionMain, Context, Operation } from 'effection';\n\ninterface MainErrorOptions {\n  exitCode?: number;\n  verbose?: boolean;\n  message?: string;\n}\n\nexport class MainError extends Error {\n  name = \"EffectionMainError\"\n\n  constructor(public options: MainErrorOptions = {}) {\n    super(options.message || \"error\");\n  }\n}\n\nexport function main<T>(operation: Operation<T>): Context<T> {\n  return effectionMain(({ context: mainContext, spawn }) => {\n    spawn(function* main() {\n      let interrupt = () => { mainContext.halt(); };\n      let debug = () => console.debug(mainContext.toString());\n      try {\n        process.on('SIGINT', interrupt);\n        process.on('SIGTERM', interrupt);\n        process.on('SIGUSR1', debug);\n        return yield operation;\n      } catch(e) {\n        if(e.name === 'EffectionMainError') {\n          if(e.options.message) {\n            console.error(e.options.message);\n          }\n          if(e.options.verbose) {\n            console.error(e.stack);\n          }\n          process.exit(e.options.exitCode || -1);\n        } else {\n          console.error(e);\n          process.exit(-1);\n        }\n      } finally {\n        process.off('SIGINT', interrupt);\n        process.off('SIGTERM', interrupt);\n        process.off('SIGUSR1', debug);\n      }\n    });\n  });\n}\n","import { Operation, resource } from 'effection';\nimport { once, throwOnErrorEvent } from '@effection/events';\n\nimport * as childProcess from 'child_process';\nimport { SpawnOptions, ForkOptions, ChildProcess } from 'child_process';\n\nexport { ChildProcess } from 'child_process';\n\nfunction *supervise(child: ChildProcess, command: string, args: readonly string[] = []) {\n  // Killing all child processes started by this command is surprisingly\n  // tricky. If a process spawns another processes and we kill the parent,\n  // then the child process is NOT automatically killed. Instead we're using\n  // the `detached` option to force the child into its own process group,\n  // which all of its children in turn will inherit. By sending the signal to\n  // `-pid` rather than `pid`, we are sending it to the entire process group\n  // instead. This will send the signal to all processes started by the child\n  // process.\n  //\n  // More information here: https://unix.stackexchange.com/questions/14815/process-descendants\n  try {\n    yield throwOnErrorEvent(child);\n\n    let [code]: [number] = yield once(child, \"exit\");\n    if(code !== 0) {\n      throw new Error(`'${(command + args.join(' ')).trim()}' exited with non-zero exit code`);\n    }\n  } finally {\n    try {\n      process.kill(-child.pid, \"SIGTERM\")\n    } catch(e) {\n      // do nothing, process is probably already dead\n    }\n  }\n}\n\nexport function *spawn(command: string, args?: ReadonlyArray<string>, options?: SpawnOptions): Operation {\n  let child = childProcess.spawn(command, args || [], Object.assign({}, options, {\n    detached: true,\n  }));\n  return yield resource(child, supervise(child, command, args));\n}\n\nexport function *fork(module: string, args?: ReadonlyArray<string>, options?: ForkOptions): Operation {\n  let child = childProcess.fork(module, args, Object.assign({}, options, {\n    detached: true,\n  }));\n  return yield resource(child, supervise(child, module, args));\n}\n"],"names":["MainError","Error","constructor","options","message","main","operation","effectionMain","context","mainContext","spawn","interrupt","halt","debug","console","toString","process","on","e","name","error","verbose","stack","exit","exitCode","off","supervise","child","command","args","throwOnErrorEvent","code","once","join","trim","kill","pid","childProcess","Object","assign","detached","resource","fork","module"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"node.cjs.development.js","sources":["../src/main.ts","../src/child_process.ts"],"sourcesContent":["import { main as effectionMain, Context, Operation } from 'effection';\r\n\r\ninterface MainErrorOptions {\r\n  exitCode?: number;\r\n  verbose?: boolean;\r\n  message?: string;\r\n}\r\n\r\nexport class MainError extends Error {\r\n  name = \"EffectionMainError\"\r\n\r\n  constructor(public options: MainErrorOptions = {}) {\r\n    super(options.message || \"error\");\r\n  }\r\n}\r\n\r\nexport function main<T>(operation: Operation<T>): Context<T> {\r\n  return effectionMain(({ context: mainContext, spawn }) => {\r\n    spawn(function* main() {\r\n      let interrupt = () => { mainContext.halt(); };\r\n      let debug = () => console.debug(mainContext.toString());\r\n      try {\r\n        process.on('SIGINT', interrupt);\r\n        process.on('SIGTERM', interrupt);\r\n        process.on('SIGUSR1', debug);\r\n        return yield operation;\r\n      } catch(e) {\r\n        if(e.name === 'EffectionMainError') {\r\n          if(e.options.message) {\r\n            console.error(e.options.message);\r\n          }\r\n          if(e.options.verbose) {\r\n            console.error(e.stack);\r\n          }\r\n          process.exit(e.options.exitCode || -1);\r\n        } else {\r\n          console.error(e);\r\n          process.exit(-1);\r\n        }\r\n      } finally {\r\n        process.off('SIGINT', interrupt);\r\n        process.off('SIGTERM', interrupt);\r\n        process.off('SIGUSR1', debug);\r\n      }\r\n    });\r\n  });\r\n}\r\n","import { Operation, resource } from \"effection\";\r\nimport { once, throwOnErrorEvent } from \"@effection/events\";\r\n\r\nimport * as npmRunPath from \"npm-run-path\";\r\nimport * as TreeKill from \"tree-kill\";\r\nconst treeKill: any = TreeKill;\r\nimport * as childProcessCross from \"cross-spawn\";\r\nimport * as childProcess from \"child_process\";\r\nimport { SpawnOptions, ForkOptions, ChildProcess } from \"child_process\";\r\n\r\nexport { ChildProcess } from \"child_process\";\r\n\r\nfunction* supervise(\r\n  child: ChildProcess,\r\n  command: string,\r\n  args: readonly string[] = []\r\n) {\r\n  // Killing all child processes started by this command is surprisingly\r\n  // tricky. If a process spawns another processes and we kill the parent,\r\n  // then the child process is NOT automatically killed. Instead we're using\r\n  // the `detached` option to force the child into its own process group,\r\n  // which all of its children in turn will inherit. By sending the signal to\r\n  // `-pid` rather than `pid`, we are sending it to the entire process group\r\n  // instead. This will send the signal to all processes started by the child\r\n  // process.\r\n  //\r\n  // More information here: https://unix.stackexchange.com/questions/14815/process-descendants\r\n  try {\r\n    yield throwOnErrorEvent(child);\r\n    let [code]: [number] = yield once(child, \"exit\");\r\n    if (code !== 0) {\r\n      throw new Error(\r\n        `'${(command + args.join(\" \")).trim()}' exited with non-zero exit code`\r\n      );\r\n    }\r\n  } finally {\r\n    try {\r\n      if (process.platform === 'win32') {\r\n        // @ts-ignore\r\n        child?.stdout?.end();\r\n        // @ts-ignore\r\n        child?.stderr?.end();\r\n        treeKill(child.pid, \"SIGTERM\", (err: Error) =>\r\n          console.error(`supervised tree-kill of process ${child.pid} failed.`, err)\r\n        );\r\n      } else {\r\n        process.kill(-child.pid, \"SIGTERM\")\r\n      }\r\n    } catch(e) {\r\n      // do nothing, process is probably already dead\r\n    }\r\n  }\r\n}\r\n\r\n// using the shell that invokes will also hide the window on windows\r\nconst withDefaults = (options: SpawnOptions | undefined): SpawnOptions => {\r\n  return {\r\n    // when windows shell is true, it runs with cmd.exe by default\r\n    // node has trouble with PATHEXT and exe\r\n    // `cross-spawn` handles running it with the shell in windows if needed\r\n    ...(process.platform === \"win32\" ? {} : { shell: true }),\r\n    stdio: \"pipe\",\r\n    // we lose exit information and events if this is\r\n    // detached in windows\r\n    detached: process.platform === \"win32\" ? false : true,\r\n    cwd: options?.cwd || process.cwd(),\r\n    // if we use true than it opens a window in windows+powershell\r\n    // mac and linux don't need it either\r\n    env: npmRunPath.env({\r\n      env: Object.assign({}, process.env, options?.env),\r\n      cwd: options?.cwd || process.cwd(),\r\n      execPath: process.execPath,\r\n    }),\r\n  };\r\n};\r\n\r\nconst c = (command: string) => {\r\n  if (process.platform !== \"win32\") return command;\r\n  if (command === \"npm\" || command === \"yarn\") {\r\n    return `${command}.cmd`;\r\n  } else {\r\n    return command;\r\n  }\r\n};\r\n\r\nexport function* spawn(\r\n  command: string,\r\n  args?: ReadonlyArray<string>,\r\n  options?: SpawnOptions\r\n): Operation {\r\n  let child = childProcessCross.spawn(\r\n    c(command),\r\n    args || [],\r\n    withDefaults(options)\r\n  );\r\n  child?.stdin?.end();\r\n  return yield resource(child, supervise(child, command, args));\r\n}\r\n\r\nexport function spawnProcess(\r\n  command: string,\r\n  args?: ReadonlyArray<string>,\r\n  options?: SpawnOptions\r\n): ChildProcess {\r\n  const spawned = childProcessCross.spawn(\r\n    c(command),\r\n    args || [],\r\n    withDefaults(options)\r\n  );\r\n  spawned?.stdin?.end();\r\n\r\n  spawned.once(\"exit\", () => {\r\n    try {\r\n      if (process.platform === 'win32') {\r\n      // @ts-ignore\r\n      child?.stdout?.end();\r\n      // @ts-ignore\r\n      child?.stderr?.end();\r\n      treeKill(spawned.pid, \"SIGTERM\", (err: Error) =>\r\n        console.error(`unsupervised tree-kill of process ${spawned.pid} failed.`, err)\r\n      );\r\n      } else {\r\n        process.kill(-spawned.pid, \"SIGTERM\")\r\n      }\r\n    } catch(e) {\r\n      // do nothing, process is probably already dead\r\n    }\r\n  });\r\n\r\n  return spawned;\r\n}\r\n\r\nexport function* fork(\r\n  module: string,\r\n  args?: ReadonlyArray<string>,\r\n  options?: ForkOptions\r\n): Operation {\r\n  let child = childProcess.fork(module, args, withDefaults(options));\r\n  child?.stdin?.end();\r\n  return yield resource(child, supervise(child, module, args));\r\n}\r\n"],"names":["MainError","Error","constructor","options","message","main","operation","effectionMain","context","mainContext","spawn","interrupt","halt","debug","console","toString","process","on","e","name","error","verbose","stack","exit","exitCode","off","treeKill","TreeKill","supervise","child","command","args","throwOnErrorEvent","code","once","join","trim","platform","stdout","end","stderr","pid","err","kill","withDefaults","shell","stdio","detached","cwd","env","npmRunPath","Object","assign","execPath","c","childProcessCross","stdin","resource","spawnProcess","spawned","fork","module","childProcess"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@effection/node/dist/node.cjs.production.min.js b/node_modules/@effection/node/dist/node.cjs.production.min.js
index 1534ca4..19bd2fa 100644
--- a/node_modules/@effection/node/dist/node.cjs.production.min.js
+++ b/node_modules/@effection/node/dist/node.cjs.production.min.js
@@ -1,2 +1,2 @@
-"use strict";var e=require("effection"),r=require("@effection/events"),o=require("child_process");class s extends Error{constructor(e={}){super(e.message||"error"),this.options=e,this.name="EffectionMainError"}}function*t(e,o,s=[]){try{yield r.throwOnErrorEvent(e);let[t]=yield r.once(e,"exit");if(0!==t)throw new Error(`'${(o+s.join(" ")).trim()}' exited with non-zero exit code`)}finally{try{process.kill(-e.pid,"SIGTERM")}catch(e){}}}exports.ChildProcess={__proto__:null,spawn:function*(r,s,n){let i=o.spawn(r,s||[],Object.assign({},n,{detached:!0}));return yield e.resource(i,t(i,r,s))},fork:function*(r,s,n){let i=o.fork(r,s,Object.assign({},n,{detached:!0}));return yield e.resource(i,t(i,r,s))}},exports.MainError=s,exports.main=function(r){return e.main(({context:e,spawn:o})=>{o((function*(){let o=()=>{e.halt()},s=()=>console.debug(e.toString());try{return process.on("SIGINT",o),process.on("SIGTERM",o),process.on("SIGUSR1",s),yield r}catch(e){"EffectionMainError"===e.name?(e.options.message&&console.error(e.options.message),e.options.verbose&&console.error(e.stack),process.exit(e.options.exitCode||-1)):(console.error(e),process.exit(-1))}finally{process.off("SIGINT",o),process.off("SIGTERM",o),process.off("SIGUSR1",s)}}))})};
+"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("effection"),r=require("@effection/events"),o=require("npm-run-path"),n=require("tree-kill"),s=require("cross-spawn"),t=require("child_process");class i extends Error{constructor(e={}){super(e.message||"error"),this.options=e,this.name="EffectionMainError"}}function l(){return(l=Object.assign||function(e){for(var r=1;r<arguments.length;r++){var o=arguments[r];for(var n in o)Object.prototype.hasOwnProperty.call(o,n)&&(e[n]=o[n])}return e}).apply(this,arguments)}const c=n;function*p(e,o,n=[]){try{yield r.throwOnErrorEvent(e);let[i]=yield r.once(e,"exit");if(0!==i)throw new Error(`'${(o+n.join(" ")).trim()}' exited with non-zero exit code`)}finally{try{var s,t;"win32"===process.platform?(null==e||null===(s=e.stdout)||void 0===s||s.end(),null==e||null===(t=e.stderr)||void 0===t||t.end(),c(e.pid,"SIGTERM",r=>console.error(`supervised tree-kill of process ${e.pid} failed.`,r))):process.kill(-e.pid,"SIGTERM")}catch(e){}}}const d=e=>l({},"win32"===process.platform?{}:{shell:!0},{stdio:"pipe",detached:"win32"!==process.platform,cwd:(null==e?void 0:e.cwd)||process.cwd(),env:o.env({env:Object.assign({},process.env,null==e?void 0:e.env),cwd:(null==e?void 0:e.cwd)||process.cwd(),execPath:process.execPath})}),u=e=>"win32"!==process.platform?e:"npm"===e||"yarn"===e?e+".cmd":e;exports.ChildProcess={__proto__:null,spawn:function*(r,o,n){var t;let i=s.spawn(u(r),o||[],d(n));return null==i||null===(t=i.stdin)||void 0===t||t.end(),yield e.resource(i,p(i,r,o))},spawnProcess:function(e,r,o){var n;const t=s.spawn(u(e),r||[],d(o));return null==t||null===(n=t.stdin)||void 0===n||n.end(),t.once("exit",()=>{try{var e,r,o,n;"win32"===process.platform?(null===(e=child)||void 0===e||null===(r=e.stdout)||void 0===r||r.end(),null===(o=child)||void 0===o||null===(n=o.stderr)||void 0===n||n.end(),c(t.pid,"SIGTERM",e=>console.error(`unsupervised tree-kill of process ${t.pid} failed.`,e))):process.kill(-t.pid,"SIGTERM")}catch(e){}}),t},fork:function*(r,o,n){var s;let i=t.fork(r,o,d(n));return null==i||null===(s=i.stdin)||void 0===s||s.end(),yield e.resource(i,p(i,r,o))}},exports.MainError=i,exports.main=function(r){return e.main(({context:e,spawn:o})=>{o((function*(){let o=()=>{e.halt()},n=()=>console.debug(e.toString());try{return process.on("SIGINT",o),process.on("SIGTERM",o),process.on("SIGUSR1",n),yield r}catch(e){"EffectionMainError"===e.name?(e.options.message&&console.error(e.options.message),e.options.verbose&&console.error(e.stack),process.exit(e.options.exitCode||-1)):(console.error(e),process.exit(-1))}finally{process.off("SIGINT",o),process.off("SIGTERM",o),process.off("SIGUSR1",n)}}))})};
 //# sourceMappingURL=node.cjs.production.min.js.map
diff --git a/node_modules/@effection/node/dist/node.cjs.production.min.js.map b/node_modules/@effection/node/dist/node.cjs.production.min.js.map
index 9bad1d7..322a42c 100644
--- a/node_modules/@effection/node/dist/node.cjs.production.min.js.map
+++ b/node_modules/@effection/node/dist/node.cjs.production.min.js.map
@@ -1 +1 @@
-{"version":3,"file":"node.cjs.production.min.js","sources":["../src/main.ts","../src/child_process.ts"],"sourcesContent":["import { main as effectionMain, Context, Operation } from 'effection';\n\ninterface MainErrorOptions {\n  exitCode?: number;\n  verbose?: boolean;\n  message?: string;\n}\n\nexport class MainError extends Error {\n  name = \"EffectionMainError\"\n\n  constructor(public options: MainErrorOptions = {}) {\n    super(options.message || \"error\");\n  }\n}\n\nexport function main<T>(operation: Operation<T>): Context<T> {\n  return effectionMain(({ context: mainContext, spawn }) => {\n    spawn(function* main() {\n      let interrupt = () => { mainContext.halt(); };\n      let debug = () => console.debug(mainContext.toString());\n      try {\n        process.on('SIGINT', interrupt);\n        process.on('SIGTERM', interrupt);\n        process.on('SIGUSR1', debug);\n        return yield operation;\n      } catch(e) {\n        if(e.name === 'EffectionMainError') {\n          if(e.options.message) {\n            console.error(e.options.message);\n          }\n          if(e.options.verbose) {\n            console.error(e.stack);\n          }\n          process.exit(e.options.exitCode || -1);\n        } else {\n          console.error(e);\n          process.exit(-1);\n        }\n      } finally {\n        process.off('SIGINT', interrupt);\n        process.off('SIGTERM', interrupt);\n        process.off('SIGUSR1', debug);\n      }\n    });\n  });\n}\n","import { Operation, resource } from 'effection';\nimport { once, throwOnErrorEvent } from '@effection/events';\n\nimport * as childProcess from 'child_process';\nimport { SpawnOptions, ForkOptions, ChildProcess } from 'child_process';\n\nexport { ChildProcess } from 'child_process';\n\nfunction *supervise(child: ChildProcess, command: string, args: readonly string[] = []) {\n  // Killing all child processes started by this command is surprisingly\n  // tricky. If a process spawns another processes and we kill the parent,\n  // then the child process is NOT automatically killed. Instead we're using\n  // the `detached` option to force the child into its own process group,\n  // which all of its children in turn will inherit. By sending the signal to\n  // `-pid` rather than `pid`, we are sending it to the entire process group\n  // instead. This will send the signal to all processes started by the child\n  // process.\n  //\n  // More information here: https://unix.stackexchange.com/questions/14815/process-descendants\n  try {\n    yield throwOnErrorEvent(child);\n\n    let [code]: [number] = yield once(child, \"exit\");\n    if(code !== 0) {\n      throw new Error(`'${(command + args.join(' ')).trim()}' exited with non-zero exit code`);\n    }\n  } finally {\n    try {\n      process.kill(-child.pid, \"SIGTERM\")\n    } catch(e) {\n      // do nothing, process is probably already dead\n    }\n  }\n}\n\nexport function *spawn(command: string, args?: ReadonlyArray<string>, options?: SpawnOptions): Operation {\n  let child = childProcess.spawn(command, args || [], Object.assign({}, options, {\n    detached: true,\n  }));\n  return yield resource(child, supervise(child, command, args));\n}\n\nexport function *fork(module: string, args?: ReadonlyArray<string>, options?: ForkOptions): Operation {\n  let child = childProcess.fork(module, args, Object.assign({}, options, {\n    detached: true,\n  }));\n  return yield resource(child, supervise(child, module, args));\n}\n"],"names":["MainError","Error","constructor","options","message","supervise","child","command","args","throwOnErrorEvent","code","once","join","trim","process","kill","pid","e","childProcess","Object","assign","detached","resource","module","operation","effectionMain","context","mainContext","spawn","interrupt","halt","debug","console","toString","on","name","error","verbose","stack","exit","exitCode","off"],"mappings":"wGAQaA,UAAkBC,MAG7BC,YAAmBC,EAA4B,UACvCA,EAAQC,SAAW,sBADRD,YAFZ,sBCDT,SAAUE,EAAUC,EAAqBC,EAAiBC,EAA0B,cAY1EC,oBAAkBH,OAEnBI,SAAwBC,OAAKL,EAAO,WAC7B,IAATI,QACK,IAAIT,WAAWM,EAAUC,EAAKI,KAAK,MAAMC,sDAI/CC,QAAQC,MAAMT,EAAMU,IAAK,WACzB,MAAMC,iDAMZ,UAAuBV,EAAiBC,EAA8BL,OAChEG,EAAQY,QAAmBX,EAASC,GAAQ,GAAIW,OAAOC,OAAO,GAAIjB,EAAS,CAC7EkB,UAAU,kBAECC,WAAShB,EAAOD,EAAUC,EAAOC,EAASC,UAGzD,UAAsBe,EAAgBf,EAA8BL,OAC9DG,EAAQY,OAAkBK,EAAQf,EAAMW,OAAOC,OAAO,GAAIjB,EAAS,CACrEkB,UAAU,kBAECC,WAAShB,EAAOD,EAAUC,EAAOiB,EAAQf,gDD9BhCgB,UACfC,OAAc,EAAGC,QAASC,EAAaC,MAAAA,MAC5CA,GAAM,gBACAC,EAAY,KAAQF,EAAYG,QAChCC,EAAQ,IAAMC,QAAQD,MAAMJ,EAAYM,uBAE1CnB,QAAQoB,GAAG,SAAUL,GACrBf,QAAQoB,GAAG,UAAWL,GACtBf,QAAQoB,GAAG,UAAWH,SACTP,EACb,MAAMP,GACQ,uBAAXA,EAAEkB,MACAlB,EAAEd,QAAQC,SACX4B,QAAQI,MAAMnB,EAAEd,QAAQC,SAEvBa,EAAEd,QAAQkC,SACXL,QAAQI,MAAMnB,EAAEqB,OAElBxB,QAAQyB,KAAKtB,EAAEd,QAAQqC,WAAa,KAEpCR,QAAQI,MAAMnB,GACdH,QAAQyB,MAAM,YAGhBzB,QAAQ2B,IAAI,SAAUZ,GACtBf,QAAQ2B,IAAI,UAAWZ,GACvBf,QAAQ2B,IAAI,UAAWV"}
\ No newline at end of file
+{"version":3,"file":"node.cjs.production.min.js","sources":["../src/main.ts","../src/child_process.ts"],"sourcesContent":["import { main as effectionMain, Context, Operation } from 'effection';\r\n\r\ninterface MainErrorOptions {\r\n  exitCode?: number;\r\n  verbose?: boolean;\r\n  message?: string;\r\n}\r\n\r\nexport class MainError extends Error {\r\n  name = \"EffectionMainError\"\r\n\r\n  constructor(public options: MainErrorOptions = {}) {\r\n    super(options.message || \"error\");\r\n  }\r\n}\r\n\r\nexport function main<T>(operation: Operation<T>): Context<T> {\r\n  return effectionMain(({ context: mainContext, spawn }) => {\r\n    spawn(function* main() {\r\n      let interrupt = () => { mainContext.halt(); };\r\n      let debug = () => console.debug(mainContext.toString());\r\n      try {\r\n        process.on('SIGINT', interrupt);\r\n        process.on('SIGTERM', interrupt);\r\n        process.on('SIGUSR1', debug);\r\n        return yield operation;\r\n      } catch(e) {\r\n        if(e.name === 'EffectionMainError') {\r\n          if(e.options.message) {\r\n            console.error(e.options.message);\r\n          }\r\n          if(e.options.verbose) {\r\n            console.error(e.stack);\r\n          }\r\n          process.exit(e.options.exitCode || -1);\r\n        } else {\r\n          console.error(e);\r\n          process.exit(-1);\r\n        }\r\n      } finally {\r\n        process.off('SIGINT', interrupt);\r\n        process.off('SIGTERM', interrupt);\r\n        process.off('SIGUSR1', debug);\r\n      }\r\n    });\r\n  });\r\n}\r\n","import { Operation, resource } from \"effection\";\r\nimport { once, throwOnErrorEvent } from \"@effection/events\";\r\n\r\nimport * as npmRunPath from \"npm-run-path\";\r\nimport * as TreeKill from \"tree-kill\";\r\nconst treeKill: any = TreeKill;\r\nimport * as childProcessCross from \"cross-spawn\";\r\nimport * as childProcess from \"child_process\";\r\nimport { SpawnOptions, ForkOptions, ChildProcess } from \"child_process\";\r\n\r\nexport { ChildProcess } from \"child_process\";\r\n\r\nfunction* supervise(\r\n  child: ChildProcess,\r\n  command: string,\r\n  args: readonly string[] = []\r\n) {\r\n  // Killing all child processes started by this command is surprisingly\r\n  // tricky. If a process spawns another processes and we kill the parent,\r\n  // then the child process is NOT automatically killed. Instead we're using\r\n  // the `detached` option to force the child into its own process group,\r\n  // which all of its children in turn will inherit. By sending the signal to\r\n  // `-pid` rather than `pid`, we are sending it to the entire process group\r\n  // instead. This will send the signal to all processes started by the child\r\n  // process.\r\n  //\r\n  // More information here: https://unix.stackexchange.com/questions/14815/process-descendants\r\n  try {\r\n    yield throwOnErrorEvent(child);\r\n    let [code]: [number] = yield once(child, \"exit\");\r\n    if (code !== 0) {\r\n      throw new Error(\r\n        `'${(command + args.join(\" \")).trim()}' exited with non-zero exit code`\r\n      );\r\n    }\r\n  } finally {\r\n    try {\r\n      if (process.platform === 'win32') {\r\n        // @ts-ignore\r\n        child?.stdout?.end();\r\n        // @ts-ignore\r\n        child?.stderr?.end();\r\n        treeKill(child.pid, \"SIGTERM\", (err: Error) =>\r\n          console.error(`supervised tree-kill of process ${child.pid} failed.`, err)\r\n        );\r\n      } else {\r\n        process.kill(-child.pid, \"SIGTERM\")\r\n      }\r\n    } catch(e) {\r\n      // do nothing, process is probably already dead\r\n    }\r\n  }\r\n}\r\n\r\n// using the shell that invokes will also hide the window on windows\r\nconst withDefaults = (options: SpawnOptions | undefined): SpawnOptions => {\r\n  return {\r\n    // when windows shell is true, it runs with cmd.exe by default\r\n    // node has trouble with PATHEXT and exe\r\n    // `cross-spawn` handles running it with the shell in windows if needed\r\n    ...(process.platform === \"win32\" ? {} : { shell: true }),\r\n    stdio: \"pipe\",\r\n    // we lose exit information and events if this is\r\n    // detached in windows\r\n    detached: process.platform === \"win32\" ? false : true,\r\n    cwd: options?.cwd || process.cwd(),\r\n    // if we use true than it opens a window in windows+powershell\r\n    // mac and linux don't need it either\r\n    env: npmRunPath.env({\r\n      env: Object.assign({}, process.env, options?.env),\r\n      cwd: options?.cwd || process.cwd(),\r\n      execPath: process.execPath,\r\n    }),\r\n  };\r\n};\r\n\r\nconst c = (command: string) => {\r\n  if (process.platform !== \"win32\") return command;\r\n  if (command === \"npm\" || command === \"yarn\") {\r\n    return `${command}.cmd`;\r\n  } else {\r\n    return command;\r\n  }\r\n};\r\n\r\nexport function* spawn(\r\n  command: string,\r\n  args?: ReadonlyArray<string>,\r\n  options?: SpawnOptions\r\n): Operation {\r\n  let child = childProcessCross.spawn(\r\n    c(command),\r\n    args || [],\r\n    withDefaults(options)\r\n  );\r\n  child?.stdin?.end();\r\n  return yield resource(child, supervise(child, command, args));\r\n}\r\n\r\nexport function spawnProcess(\r\n  command: string,\r\n  args?: ReadonlyArray<string>,\r\n  options?: SpawnOptions\r\n): ChildProcess {\r\n  const spawned = childProcessCross.spawn(\r\n    c(command),\r\n    args || [],\r\n    withDefaults(options)\r\n  );\r\n  spawned?.stdin?.end();\r\n\r\n  spawned.once(\"exit\", () => {\r\n    try {\r\n      if (process.platform === 'win32') {\r\n      // @ts-ignore\r\n      child?.stdout?.end();\r\n      // @ts-ignore\r\n      child?.stderr?.end();\r\n      treeKill(spawned.pid, \"SIGTERM\", (err: Error) =>\r\n        console.error(`unsupervised tree-kill of process ${spawned.pid} failed.`, err)\r\n      );\r\n      } else {\r\n        process.kill(-spawned.pid, \"SIGTERM\")\r\n      }\r\n    } catch(e) {\r\n      // do nothing, process is probably already dead\r\n    }\r\n  });\r\n\r\n  return spawned;\r\n}\r\n\r\nexport function* fork(\r\n  module: string,\r\n  args?: ReadonlyArray<string>,\r\n  options?: ForkOptions\r\n): Operation {\r\n  let child = childProcess.fork(module, args, withDefaults(options));\r\n  child?.stdin?.end();\r\n  return yield resource(child, supervise(child, module, args));\r\n}\r\n"],"names":["MainError","Error","constructor","options","message","treeKill","TreeKill","supervise","child","command","args","throwOnErrorEvent","code","once","join","trim","process","platform","stdout","end","stderr","pid","err","console","error","kill","e","withDefaults","shell","stdio","detached","cwd","env","npmRunPath","Object","assign","execPath","c","childProcessCross","stdin","resource","spawned","module","childProcess","operation","effectionMain","context","mainContext","spawn","interrupt","halt","debug","toString","on","name","verbose","stack","exit","exitCode","off"],"mappings":"yOAQaA,UAAkBC,MAG7BC,YAAmBC,EAA4B,UACvCA,EAAQC,SAAW,sBADRD,YAFZ,qOCJT,MAAME,EAAgBC,EAOtB,SAAUC,EACRC,EACAC,EACAC,EAA0B,cAalBC,oBAAkBH,OACnBI,SAAwBC,OAAKL,EAAO,WAC5B,IAATI,QACI,IAAIX,WACHQ,EAAUC,EAAKI,KAAK,MAAMC,8DAKR,UAArBC,QAAQC,UAEVT,MAAAA,aAAAA,EAAOU,uBAAQC,MAEfX,MAAAA,aAAAA,EAAOY,uBAAQD,MACfd,EAASG,EAAMa,IAAK,UAAYC,GAC9BC,QAAQC,yCAAyChB,EAAMa,cAAeC,KAGxEN,QAAQS,MAAMjB,EAAMa,IAAK,WAE3B,MAAMK,MAOZ,MAAMC,EAAgBxB,QAKO,UAArBa,QAAQC,SAAuB,GAAK,CAAEW,OAAO,IACjDC,MAAO,OAGPC,SAA+B,UAArBd,QAAQC,SAClBc,KAAK5B,MAAAA,SAAAA,EAAS4B,MAAOf,QAAQe,MAG7BC,IAAKC,MAAe,CAClBD,IAAKE,OAAOC,OAAO,GAAInB,QAAQgB,IAAK7B,MAAAA,SAAAA,EAAS6B,KAC7CD,KAAK5B,MAAAA,SAAAA,EAAS4B,MAAOf,QAAQe,MAC7BK,SAAUpB,QAAQoB,aAKlBC,EAAK5B,GACgB,UAArBO,QAAQC,SAA6BR,EACzB,QAAZA,GAAiC,SAAZA,EACbA,SAEHA,6CAIX,UACEA,EACAC,EACAP,aAEIK,EAAQ8B,QACVD,EAAE5B,GACFC,GAAQ,GACRiB,EAAaxB,WAEfK,MAAAA,aAAAA,EAAO+B,sBAAOpB,YACDqB,WAAShC,EAAOD,EAAUC,EAAOC,EAASC,kBAGzD,SACED,EACAC,EACAP,eAEMsC,EAAUH,QACdD,EAAE5B,GACFC,GAAQ,GACRiB,EAAaxB,WAEfsC,MAAAA,aAAAA,EAASF,sBAAOpB,MAEhBsB,EAAQ5B,KAAK,OAAQ,qBAEQ,UAArBG,QAAQC,oBAEZT,gCAAOU,uBAAQC,gBAEfX,gCAAOY,uBAAQD,MACfd,EAASoC,EAAQpB,IAAK,UAAYC,GAChCC,QAAQC,2CAA2CiB,EAAQpB,cAAeC,KAG1EN,QAAQS,MAAMgB,EAAQpB,IAAK,WAE7B,MAAMK,OAKHe,QAGT,UACEC,EACAhC,EACAP,aAEIK,EAAQmC,OAAkBD,EAAQhC,EAAMiB,EAAaxB,WACzDK,MAAAA,aAAAA,EAAO+B,sBAAOpB,YACDqB,WAAShC,EAAOD,EAAUC,EAAOkC,EAAQhC,gDD3HhCkC,UACfC,OAAc,EAAGC,QAASC,EAAaC,MAAAA,MAC5CA,GAAM,gBACAC,EAAY,KAAQF,EAAYG,QAChCC,EAAQ,IAAM5B,QAAQ4B,MAAMJ,EAAYK,uBAE1CpC,QAAQqC,GAAG,SAAUJ,GACrBjC,QAAQqC,GAAG,UAAWJ,GACtBjC,QAAQqC,GAAG,UAAWF,SACTP,EACb,MAAMlB,GACQ,uBAAXA,EAAE4B,MACA5B,EAAEvB,QAAQC,SACXmB,QAAQC,MAAME,EAAEvB,QAAQC,SAEvBsB,EAAEvB,QAAQoD,SACXhC,QAAQC,MAAME,EAAE8B,OAElBxC,QAAQyC,KAAK/B,EAAEvB,QAAQuD,WAAa,KAEpCnC,QAAQC,MAAME,GACdV,QAAQyC,MAAM,YAGhBzC,QAAQ2C,IAAI,SAAUV,GACtBjC,QAAQ2C,IAAI,UAAWV,GACvBjC,QAAQ2C,IAAI,UAAWR"}
\ No newline at end of file
diff --git a/node_modules/@effection/node/package.json b/node_modules/@effection/node/package.json
index 927241e..d7c01e5 100644
--- a/node_modules/@effection/node/package.json
+++ b/node_modules/@effection/node/package.json
@@ -19,8 +19,9 @@
     "mocha": "mocha -r ts-node/register"
   },
   "devDependencies": {
-    "@effection/events": "^0.7.4",
+    "@effection/events": "^0.7.7",
     "@frontside/tsconfig": "0.0.1",
+    "@types/cross-spawn": "^6.0.2",
     "@types/node": "^13.13.2",
     "@types/node-fetch": "^2.5.7",
     "expect": "^25.4.0",
@@ -31,8 +32,11 @@
     "typescript": "^3.7.0"
   },
   "dependencies": {
+    "@effection/events": "^0.7.7",
+    "cross-spawn": "^7.0.3",
     "effection": "^0.7.0",
-    "@effection/events": "^0.7.4"
+    "npm-run-path": "^4.0.1",
+    "tree-kill": "^1.2.2"
   },
   "volta": {
     "node": "12.16.0",
diff --git a/node_modules/@effection/node/src/child_process.ts b/node_modules/@effection/node/src/child_process.ts
index e31a9a9..5a8652a 100644
--- a/node_modules/@effection/node/src/child_process.ts
+++ b/node_modules/@effection/node/src/child_process.ts
@@ -1,12 +1,20 @@
-import { Operation, resource } from 'effection';
-import { once, throwOnErrorEvent } from '@effection/events';
+import { Operation, resource } from "effection";
+import { once, throwOnErrorEvent } from "@effection/events";
 
-import * as childProcess from 'child_process';
-import { SpawnOptions, ForkOptions, ChildProcess } from 'child_process';
+import * as npmRunPath from "npm-run-path";
+import * as TreeKill from "tree-kill";
+const treeKill: any = TreeKill;
+import * as childProcessCross from "cross-spawn";
+import * as childProcess from "child_process";
+import { SpawnOptions, ForkOptions, ChildProcess } from "child_process";
 
-export { ChildProcess } from 'child_process';
+export { ChildProcess } from "child_process";
 
-function *supervise(child: ChildProcess, command: string, args: readonly string[] = []) {
+function* supervise(
+  child: ChildProcess,
+  command: string,
+  args: readonly string[] = []
+) {
   // Killing all child processes started by this command is surprisingly
   // tricky. If a process spawns another processes and we kill the parent,
   // then the child process is NOT automatically killed. Instead we're using
@@ -19,30 +27,115 @@ function *supervise(child: ChildProcess, command: string, args: readonly string[
   // More information here: https://unix.stackexchange.com/questions/14815/process-descendants
   try {
     yield throwOnErrorEvent(child);
-
     let [code]: [number] = yield once(child, "exit");
-    if(code !== 0) {
-      throw new Error(`'${(command + args.join(' ')).trim()}' exited with non-zero exit code`);
+    if (code !== 0) {
+      throw new Error(
+        `'${(command + args.join(" ")).trim()}' exited with non-zero exit code`
+      );
     }
   } finally {
     try {
-      process.kill(-child.pid, "SIGTERM")
+      if (process.platform === 'win32') {
+        // @ts-ignore
+        child?.stdout?.end();
+        // @ts-ignore
+        child?.stderr?.end();
+        treeKill(child.pid, "SIGTERM", (err: Error) =>
+          console.error(`supervised tree-kill of process ${child.pid} failed.`, err)
+        );
+      } else {
+        process.kill(-child.pid, "SIGTERM")
+      }
     } catch(e) {
       // do nothing, process is probably already dead
     }
   }
 }
 
-export function *spawn(command: string, args?: ReadonlyArray<string>, options?: SpawnOptions): Operation {
-  let child = childProcess.spawn(command, args || [], Object.assign({}, options, {
-    detached: true,
-  }));
+// using the shell that invokes will also hide the window on windows
+const withDefaults = (options: SpawnOptions | undefined): SpawnOptions => {
+  return {
+    // when windows shell is true, it runs with cmd.exe by default
+    // node has trouble with PATHEXT and exe
+    // `cross-spawn` handles running it with the shell in windows if needed
+    ...(process.platform === "win32" ? {} : { shell: true }),
+    stdio: "pipe",
+    // we lose exit information and events if this is
+    // detached in windows
+    detached: process.platform === "win32" ? false : true,
+    cwd: options?.cwd || process.cwd(),
+    // if we use true than it opens a window in windows+powershell
+    // mac and linux don't need it either
+    env: npmRunPath.env({
+      env: Object.assign({}, process.env, options?.env),
+      cwd: options?.cwd || process.cwd(),
+      execPath: process.execPath,
+    }),
+  };
+};
+
+const c = (command: string) => {
+  if (process.platform !== "win32") return command;
+  if (command === "npm" || command === "yarn") {
+    return `${command}.cmd`;
+  } else {
+    return command;
+  }
+};
+
+export function* spawn(
+  command: string,
+  args?: ReadonlyArray<string>,
+  options?: SpawnOptions
+): Operation {
+  let child = childProcessCross.spawn(
+    c(command),
+    args || [],
+    withDefaults(options)
+  );
+  child?.stdin?.end();
   return yield resource(child, supervise(child, command, args));
 }
 
-export function *fork(module: string, args?: ReadonlyArray<string>, options?: ForkOptions): Operation {
-  let child = childProcess.fork(module, args, Object.assign({}, options, {
-    detached: true,
-  }));
+export function spawnProcess(
+  command: string,
+  args?: ReadonlyArray<string>,
+  options?: SpawnOptions
+): ChildProcess {
+  const spawned = childProcessCross.spawn(
+    c(command),
+    args || [],
+    withDefaults(options)
+  );
+  spawned?.stdin?.end();
+
+  spawned.once("exit", () => {
+    try {
+      if (process.platform === 'win32') {
+      // @ts-ignore
+      child?.stdout?.end();
+      // @ts-ignore
+      child?.stderr?.end();
+      treeKill(spawned.pid, "SIGTERM", (err: Error) =>
+        console.error(`unsupervised tree-kill of process ${spawned.pid} failed.`, err)
+      );
+      } else {
+        process.kill(-spawned.pid, "SIGTERM")
+      }
+    } catch(e) {
+      // do nothing, process is probably already dead
+    }
+  });
+
+  return spawned;
+}
+
+export function* fork(
+  module: string,
+  args?: ReadonlyArray<string>,
+  options?: ForkOptions
+): Operation {
+  let child = childProcess.fork(module, args, withDefaults(options));
+  child?.stdin?.end();
   return yield resource(child, supervise(child, module, args));
 }
diff --git a/node_modules/@effection/node/src/index.ts b/node_modules/@effection/node/src/index.ts
index 5c22657..f1c33b6 100644
--- a/node_modules/@effection/node/src/index.ts
+++ b/node_modules/@effection/node/src/index.ts
@@ -1,2 +1,3 @@
 export { main, MainError } from './main';
-export * as ChildProcess from './child_process';
+import * as ChildProcess from './child_process';
+export { ChildProcess }
diff --git a/node_modules/@effection/node/tsconfig.dist.json b/node_modules/@effection/node/tsconfig.dist.json
new file mode 100644
index 0000000..ecaaa52
--- /dev/null
+++ b/node_modules/@effection/node/tsconfig.dist.json
@@ -0,0 +1,8 @@
+{
+  "extends": "./tsconfig",
+  "compilerOptions": {
+    "module": "esnext",
+    "esModuleInterop": true
+  },
+  "exclude": ["./test/*"]
+}
diff --git a/node_modules/@effection/node/tsconfig.json b/node_modules/@effection/node/tsconfig.json
new file mode 100644
index 0000000..835c7c0
--- /dev/null
+++ b/node_modules/@effection/node/tsconfig.json
@@ -0,0 +1,7 @@
+{
+  "extends": "@frontside/tsconfig",
+  "include": [
+    "src/**/*.ts",
+    "test/**/*.ts"
+  ]
+}
